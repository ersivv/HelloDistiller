// контроль нуля идет на 1-е прерывание (это pin 3)
// Управление симистором для фазового регулятора мощности реализовано через PIN 36
// АЦП от трансформатора подключен на pin А2 (раньше шел на pin A3)
// Датчики ds18b20 сидят на 37 пине. (потому что на пины с 7 по 13 я подключил ULM2003, из-за желания использовать встроенный ШИМ в Ардуино)


// Кнопки подключены на следующие пины:
// почему на этих - да потому, что они рядом идут, и еще пин земли рядом, а гребенку 6 онтактов проще паять и подключать, чем каждый контакт одтельно
// PIN_SELECT 53
// PIN_RIGHT 51
// PIN_LEFT 49
// PIN_UP 45
// PIN_DOWN 47

// Уровень НПГ подключен по следующей схеме: Подтяджка - 10 ком, защита -330 ом, опорное, 2.56, замыкание - 59, резистор 1.1К - 242, 2.2К - 399, 3,3К - 521
// нижний уровень резистор 1.1К, рабочий уровень резистор 2.2К  верхиний уровень резистор 3,3К. Подтяжка аналогового пина на +5В резистором в 10 Ком.

// Почему-то иногда глючит дисплей - когда это происходит (на нем появляются иероглифы или перестает отображаться текст),
// нажать и держать одновременно клавишу влево и впрёаво, либо клавишей вправо перейти на 6-ю страницу, дисплей переинициализируется.
// одновременное нажатие кнопок вверх и вних позволчет перейти к следующему этапу процесса ректификации , также можно сделать это на 8 странице кнопками вверх и вниз однако это не рекомендуется работа не гаранитируется.

// Клапана для управления ШИМ подключены, начиная с PIN 22
// Всего максимум 5 клапанов, то есть на пины с 22 по 26 реализован
// программный ШИМ по количество полупериодов с контролем нуля.


// Дисплей на следующих пинах - почему на этих - да потому, что они рядом идут, и еще пин земли рядом, как раз для вывода R/W дисплея
// а гребенку из 7 контактов проще паять и подключать, чем каждый контакт одтельно
// LiquidCrystal lcd(52,50, 48, 46, 44, 42);

//#define TEST   // Раскомметировать, если нужно получать всяческие тестовые значения через Serial1
//#define TESTGSM   // Раскомметировать, если нужно дублировать входящюю информацияю из serial2 (сотового телефона) в Serial1 (для отладки)
//#define TESTRM   // Раскомметировать, если нужно получать тестовые значения регулятора мощности через Serial1
//#define TESTERR   // Раскомметировать, если нужно получать тестовые значения ошибок через Serial1

//#define DEBUG  // Режим отладки, в этом режиме не считываются значения датчиков температуры, а они передаются через монитор порта в ардуине
// в формате: сколько прибавить секунд, Температура датчика 0, Температура датчика 1,Температура датчика 2
// например: 60,820,810,800
//  (монитор порта надо настроить так, чтобы он выдавал возврат каретки и перевод строки) 
#define SIMPLED_VERSION 0      // Признак того, насколько упрощена версия
// 0 - стандартная
// 1 - с твердотельным реле в качестве регулятора мощности по брезинхему, с датчиком ASC712 30A в качестве датчика напряжения в сети
// с двумя релейным модуля для управления клапанами отбором голов и хвостов и товарного спирта.
// LCD keypad shield в качестве кнопок и экрана.
// 2 - то же, что и 1, но с цифровыми датчиками уровня спирта, голов, разлития жидкости
// 3 - то же, что и 2, но только с одним датчиком уровня спирта без датчика голов и разлития жидкости.
// 4 - то же что и 3, но с датчиком напряжения на трансформаторе.
// 5 - это почти нулевая версия, но разгон и двигатель управляются реле с низким уровнем и используется LCD keypad shield в качестве дисплея и кнопок.
// 6-  то же что и 5 но с поддержкой НПГ, с расчетом фактической мощности через датчик тока..
// 7 - slave конороллер, управляемый через внешние пины.
// 8 - То же что и 2, но с аналоговыми датчиками уровня спирта, голов, разлития жидкости.
// 9 - То же что и 5, но с расчетом фактической мощности через датчик тока.

#define USE_I2C_DISPLAY       0 // 1 - использовать дисплей I2C, 0 - не испольновать при использовании I2C раскомментировать две нижеследующие строчки
//#include <Wire.h>               //при использовании I2C раскомментировать
//#include <LiquidCrystal_I2C.h>  //при использовании I2C раскомментировать
#define KLP_HIGH 1              // Для клапанов с низким уровнем управления поменять 0 на 1

#define USE_LCD_KEYPAD_SHIELD 1  // 1 - использовать стандартный шильд с кнопкми ардуино, 0 - не использовать
//#define USE_PROVODIMOST_SR    2 // (теперь за это отвечает переменная UrovenProvodimostSR) 1 - использовать датчик проводимости спирта для контроля окончания голов, 0 - не использовать,
// 2 - использовать датчик проводимости как индикатор наполнения приемной емкости с головами.

int UrovenProvodimostSR = 0;   // Уровень проводимости, меньше которого считаем, что закончились головы и начался спирт.
int UrovenBarda = 250;        // Уровень сигнала, достижение котогого свидетельсвует о срабатывании датчика бардоотводчика.

#define PIN_PROVODIMOST_SR A7        // Пин для анализа проводимости спирта (аналоговый пин А7)
#define MAX_COUNT_PROVODIMOST_SR 6  // Количество срабатываний датчика, по достижении которых можно точно сказать, что головы закончились
// Каждое значение - это 5 секунд, то есть в данном случае датчик должен показывать 30 секунд проводимость менее 20


#define UROVEN_ALARM 50        // Уровень сигнала, достижение котогого свидетельсвует о срабатывании аналогового датчика (в обычном состоянии он выведен на значение около 1000 для датчиков на уменьшение напряжения)
// или на значение около 0-10 для датчиков на увеличение напряжения 
#define COUNT_ALARM 6          // Сколько должно держаться значение уровня, чтобы сработало предупреждение каждое значение - это полсекунды.
#define COUNT_ALARM_VODA 60    // Сколько должно держаться значение разлития воды, чтобы сработала тревога каждое значение - это полсекунды.
#define COUNT_ALARM_UROVEN 200 // Сколько должно держаться значение уровня, чтобы сработала тревога по уровню в приемной емкости каждое значение - это полсекунды.

#define PIN_GAS_SENSOR A8        // Пин для анализа датчика загазованности (спирта)
#define USE_GAS_SENSOR 0        // Надо ли использовать датчик загазованности
#define UROVEN_GAS_SENSOR 700    // Уровень сигнала, достижение котогого свидетельсвует о срабатывании датчика спиртового пара
#define COUNT_GAS_SENSOR 6          // Сколько должно держаться значение уровня, чтобы сработала тревога каждое значение - это полсекунды.

#define TIME_PROGREV_GAS_SENSOR 60    // Время для програва датчика спиртовых паров газа.


#define USE_ALARM_UROVEN 2  // Нужно ли использовать датчик уровня в приемной емкости ардуино 1- использовать для остановки всег процесса
// 2 - датчик используется как уровень при котором останавливается отбор, но не останавливается ректификация
#define USE_ALARM_VODA   1  // Нужно ли использовать датчик разлития воды ардуино

#define NPG_UROVEN_PIN A3         // Пин уровня НПГ. (закомментировать, если НПГ не используется во избежании ложных сработок)

#define MAX_COUNT_NPG_ALARM 4     // Количество сработок осушения или переполнения, чтобы достоверно детектировать состояние НПГ (каждое значение -полсекунды)

#define PIN_MPX5010 A9      // Пин датчика давления MPX5010DP

#define PIN_DVIGATEL 28 // Пин управления двигателем в фазовом режиме (не исползуется).

#define PIN_NASOS_NBK 12  // Пин управления насосом НБК через ШИМ (двигатель не шаговый, подключать полевик, например IRL2703 или транзисторный ключ или драйвер полевика).
unsigned char zPS = 0; // Число прерываний нуля за секунду.
unsigned char zPSOut = 0; // Число прерываний нуля за секунду для вывода на экран.
#define PIN_LIGHT 10
unsigned char LedLight = 200;

int TimeStabKolonna = 900; // Время стабилизации колонны (положительное значение - время от последнего изменения температуры, отрицательное - абсолютное время).

#define MAX_TABLE_T 200

int tableT[MAX_TABLE_T + 1]; //табличное значение времени задежки открытия триака

#define MAX_TABLE_SQRT 34
unsigned char tableSQRT[MAX_TABLE_SQRT + 1];  //Значение корня
unsigned int tableSQ[MAX_TABLE_SQRT + 1];     //Значение квадрата


int timeNBK = 0;   // Время работы насоса НБК в секундах со скоростью SpeedNKB. По истечении этого времени насос остановится

#define PIN_MIXER     32  // Пин управления мешалокой 

int timeMIXER = 0; // Время работы двигателя миксера в секундах. По истечении этого времени мешалка остановится

int time1 = 0;   // Таймер для отсчета секунд 1
int time2 = 0;   // Таймер для отсчета секунд 2
int time3 = 0;   // Таймер для отсчета секунд 3


int U_MPX5010 = 0;        // Текущее значение давления (в 10 мм р.ст, то есть 100, это 10 мм рст).
int P_MPX5010 = 0;       // Поправка для датчика  
int countAlrmNPG = 0;  // Количество сработок тревоги НПГ.

//#ifdef TESTRM
#define Serial1 Serial  // Закомментировать, если используется Serial1, вместо стандартного порта, например используется BlueTooth.
//#endif

// Номер телефона
#define USE_DIFAVTOMAT 1       // Константа, которая показывает, используется ли дифавтомат в работе системы нужно для того, чтобы при нормальном завершении процесса
// при плановом отключении дифавтомата не выдавалась тревога.
char my_phone[] = "+77777777777";
char my_version[] = "v2.81";

#define PEREGREV_ON 1  // Того, что надо использовать режим работы клапана в режиме защиты от перегрева. 1- использовать, 0-нет.

unsigned int NaprPeregrev = 300;  // Какое среднеквадратичное надо поддерживать для защиты клапанов от перегрева.

#if PEREGREV_ON==0
#define PER_KLP_OPEN  1 // клапана открываем через полу-период (аналог диода), чтобы не перегревались и
#define PER_KLP_CLOSE 1 // чтобы не быо гидроударов
#else
#define PER_KLP_OPEN  1000 // клапана на воду переводим в фазовое управление, чтобы раз в 10 секунд на них подавалось полное напряжение, а затем напряжение
#define PER_KLP_CLOSE 0    // из контанты NAPR_PEREGREV 150 
#endif

#define PIN_READU A2         // Аналоговый Пин для чтения сетевого напряжения (тока) 
#define PIN_READI A2         // Аналоговый Пин для чтения тока 

#define SENSITIVE_ASC712 135 // Чувствительность датчика тока (показаний АЦП ардуино на 10 ампер тока 135 для 30А датчика, 205 для 20А датчика)
#define USE_ASC712 0           // Надо ли исполозовать датчик тока
#define PIN_DS18B20 37
#define RELAY_HIGH 1         // Какой сигнал подавать на релейные выходы мешалки и разгона 

#define ALL_OFF_HIGH 1         // Какой сигнал подавать на релейные выходы мешалки и разгона 

#define PIN_TRIAC  36    // Управление симистором реализовано через PIN 36
//#define USE_CORR_ASC712 0  // Надо ли использовать датчик тока для вывода фактической среднеквадратичной мощности.
char CorrectASC712;      // Признак того, как надо использовать датчик asc712 
// (0- не надо, 1 - только показывать мощность, 2-корректировать мощность через фактический ток, 3- ПИД регулирование через ток)

char flCorrASC712 = 0; // Флаг того, что надо расчитывать в данный момент среднеквадратичную мощность 1-мощность, 2-напряжение.

#if SIMPLED_VERSION==0
// Константа определяющая датчик потока воды.
#define FLOW_DETECT_ON 4987 // Число оборотов датчика 19950 - это на 0.5 литрА 
#define FLOW_MLITR     8  // На указанное число делителя миллилитров воды (то есть 10 - это 100мл, 2 -500, 4-250, 8-125).
#endif

int FlowCount = 0;
#ifdef FLOW_DETECT_ON
long FlowBegTime = 0; // Начало подсчета оборотов
#endif
unsigned int Sec5;      // 1/5 секунды
int Flow = 0;

//#define ULTRASONIC_PIN 40  // Пин trig датчика расстояния, следующий пин должен быть Echo, то есть в данном случае 40, это trig, Echo это 41

int Distance = 0;            // Текущее расстояние

#ifdef ULTRASONIC_PIN
long BegDistance;
#endif

// Номер телефона
char sms_start[] = "0410"; // SMS для старта (рестарта процесса), это большая русская буква А в формате UNICODE 
// (обязательно надо использовать русские буквы, чтобы SMS гарантированно пришел в формате UNICODE, другие программа 
// анализировать не может, точнее может, но надо заранее тогда знать, что придет последними 4 байтами в сообщении.
char sms_stop[] = "0411"; // SMS для остановки процесса, это большая русская буква Б в формате UNICODE

char lastSMSState = 0; // Последнее отправленное состояние по SMS (Чтобы не отправлять его многократно)
char pdu_phone[14];  // Номер телефона в формате отправки SMS (заполняется автоматически)
char CntErrDs18 = 0;   // Количество глюков, зафиксированных от датчика 
char NumErrDs18 = 0;   // Номер сглючившего датчика
char NumErr = 0;       // Код ошибки 1 - глючит датчик ds18b20

unsigned char SpeedNBK = 0;
#define MAX_ERR_DS18 20 // После двадцати глюков подряд (а это двадцать секунд) от датчиков температуры, считаем, что процесс надо остановить.



//#define STAB_RM 1  // Поставить 1, если программе пытаться стабилизировать регулятор мощности, путем запрета вывода информации на дисплей в момент работы, чтения температуры и т.д.
// Поставить 0, если идет отладка программы без подключенных датчиков, контроллера детектора нуля, схемы измерения текущего напряжения в сети. 

#if USE_I2C_DISPLAY==0
#include <LiquidCrystal.h>
#else
// Если используем I2C дисплей, тогда подгружаем соответствующюю библиотеку
//  #include <Wire.h> 
//  #include <LiquidCrystal_I2C.h>
#endif

#include <OneWire.h>

#include <EEPROM.h> 

#define PR_REWRITE_EEPROM 9  // Константа, которая содержит признак необходимости перезаписи энергонезависимой памяти (1-254). 
// При запуске программы, значение 0-го байта ЕЕПРОМ сравнивается с этим знначением, 
// и если они не совпадают, тогда энергонезависимая памиять переписывается текущими значениями переменных
// То есть для перезаписи контанты при первом запуске, ее значение надо поменять

unsigned int ee_addr; // Переменная для хранения текущего адреса чтения/записи в EEPROM


unsigned char eeReadChar()
{
	unsigned char lByte = EEPROM.read(ee_addr);
	ee_addr++;
	return lByte;
}

void eeWriteChar(char p_value)
{
	if (EEPROM.read(ee_addr) != p_value)
		EEPROM.write(ee_addr, p_value);
	ee_addr++;
}

void eeWriteInt(int p_value)
{
	unsigned char lByte = (unsigned char)(p_value);
	unsigned char hByte = (unsigned char)(p_value >> 8);

	// Для экономии ресурса флеш памяти, сначала проверяем ее содержимое и запись производим только если значение отличается.
	eeWriteChar(lByte);
	eeWriteChar(hByte);
}

//This function will read a 2 byte integer from the eeprom at the specified address and address + 1
unsigned int eeReadInt()
{
	unsigned char lByte = eeReadChar();
	unsigned char hByte = eeReadChar();
	return (unsigned int)(lByte) | (unsigned int)(hByte << 8);
}


#define MAX_INDEX_INPUT 540

#define MAX_INDEX_BY_PERIOD 90
#define MIN_INDEX_BY_PERIOD 75

#define CNT_PERIOD 4  // Кооличество полу-периодов для обсчета среднеквадратичного

unsigned char ErrCountIndex = 0;

#define BEEP_LONG 20   //Длительность сигнала оповещения о состояниях процесса

//int data_adc[MAX_INDEX_INPUT+1];
//#ifdef TESTRM
//int tic_adc[MAX_INDEX_INPUT+1];
//#endif

char lcd_buffer[33]; //Буфер для хранения данных для вывода на дисплей
char CntPeriod = 0; //Номер обсчитываемого полу-периода
#define MY_RX_BUFFER_SIZE 70
#define MY_TX_BUFFER_SIZE 70
char my_tx_buffer[MY_TX_BUFFER_SIZE];
char my_rx_buffer[MY_RX_BUFFER_SIZE];
char pos_rx_buffer = 0;
int NewErr;// Новая ошибка рассогласования

unsigned long SqNaprT = 0, SqNaprPrevT = 0; //  Переменные для накапливания квадратов напряжений.

int OldErrOut;// Новая ошибка рассогласования
int OldErr;// Старая ошибка рассогласования
int It;     // Интегральная составляющая (без коэффициентов, чтобы избавиться от дробей, коэффициенты учтем в момент ее применения);
int Dt;     // Дифференциальная составляющая (без коэффициентов, чтобы избавиться от дробей, коэффициенты учтем в момент ее применения);

int  FlState = 0;  // Флаг состоянияч конечного автомата обработки нажатия кнопок клавиатуры 
unsigned char  IspReg = 101; // Используемый в данный момент режим (по умолчанию пока ставим регулятор мощности)
char  DispPage = 0; // Какую страницу отображать на дисплее
int TempTerm = 200;
int Delta = 5;
char FlToGSM = 0;        // Признак того, что сотовый используется для вывода информации
char FlToUSART = 0;      // Признак того, что CОМ-порт используется для вывода информации
char BeepEndProcess = 1; // Пищать динамиком по окончании процесса.
char BeepStateProcess = 1; // Пищать динамиком при переходе между процессами.
char BeepKeyPress = 1; // Пищать динамиком при нажатии на клавиши
int Temp1P = 992;        // Температура первой (недробной) перегонки 
int Temp2P = 964;        // Температура второй  перегонки  (дистилляция без дефлегматора)
int Temp3P = 954;        // Температура третьей перегонки  (дистилляция без дефлегматора)
int TempKipenZator = 800;// Температура начала закипания затора (либо это температура в верхней части заторника (если два термометра, либо в заторнике, если стоит один термометр)
int TempZasypSolod = 680;// Температура при которой можно засыпать солод.
int TempHLDZatorBrog = 355;// Температура начала закипания затора (либо это температура в верхней части заторника (если два термометра, либо в заторнике, если стоит один термометр)
int PowerGlvDistil = 800; // Мощность отбора голов при простой дистилляции
int PowerDistil = 3000; // Мощность дистилляции
int PowerNBK = 2400; // Мощность дистилляции
unsigned char SpeedNBKDst = 0; // Скорость насоса НБК
int PowerRazvZerno = 820; // Мощность, при которой будут развариваться зерновые (2 часа).
int PowerVarkaZerno = 3000; // Мощность, при которой будут варится зерновые и доводиться до кипения (она меньше, чем мощность ТЭНов, потому что на полной мощности может быть факелирование).

int TempDeflBegDistil = 700; //Температура в дефлегматоре, для начала подачи воды в холодильник.
int TempDefl = 820; //Температура в дефлегматоре, которую надо поддерживать путем включения клапана дефлегматора
unsigned char DeltaDefl = 20; //дельта Температуры в дефлегматоре, которую надо поддерживать путем включения клапана дефлегматора
int tEndDistDefl = 985;       // Температура в кубе, при которой надо прекращать дистилляцию с дефлегматором 
int timerMinute = 0;          // Время для таймера
int PowerMinute = 0;          // Установленная мощность
int tEndRectRazgon = 830;     // Температура окончания режима разгона 83.0 С
int PowerRect = 1000;     // Мощность ректификации
int tStabSR;// Температура, относительно которой стабилизируется отбор СР
char ProcChimSR;// Текущий процент отбора СР
long SecTempPrev;// Знчение секудндомера, при котором было считана эта температура.
long SecOstatok;// Знчение секудндомера, сколько еще осталось до стабилизации
int TempPrev = 0;// Значение предыдущей температуры (для сверки с текущей (проверка стабилизации значение 344 для облегчения отладки)

int tEndRectOtbGlv = 854;     // Температура окончания отбора голов 85.4 С
unsigned int timeChimRectOtbGlv = 2000;  // Шим отбора голов (в полупериодах сетевого напряжения в данном случае это около 20 секунд)
unsigned char ProcChimOtbGlv = 5;  // Процент ШИМ отбора голов (в данном случае это 5 процентов)
unsigned int timeChimRectOtbSR = 1000;  // Шим отбора голов (в полупериодах сетевого напряжения в данном случае это около 10 секунд)
unsigned char tDeltaRect = 10;  // Дельта ректификации (в десятых градуса Цельсия) в данном случае - это 10 десятых, то есть 1 градус Цельсия
unsigned int tEndRectOtbSR = 965;  // Температура окончания отбора спирта-ректификата и начала отбора хвостов (в данном случе 96.5 С)
unsigned int tEndRect = 995;       // Температура в кубе, при которой прекращается ректификация (в данном случе 99.5 С)
unsigned char minProcChimOtbSR = 20;  // Минимальный ШИМ, за который нельзя выходить при отборе СР
unsigned char begProcChimOtbSR = 40;  // Начальный ШИМ отбора СР

char StateMachine = 0; // Состояние конечного автомата процесса 
char flNeedReadAlarm;// Флаг того, что нужно анализировать состояние датчиков НПГ, Уровня в приемной емкости, Разлития по полу.
char flAlarmUroven = 0; // Флаг того, что уровень в приемной емкости достик предела

char FlUsart = 0; // Признак того, что надо вывести информацию на СОМ-порт
char flRing = 0; // Признак наличия звонка от своего номера (запрос на СМС о состоянии процесса);

char flNeedAnalyse = 0; // Флаг того, что надо анализировать результат измерения температуры
//char flStateProcess=0;
char flNeedScanKbd = 0; // Флаг того, что надо читать состояние клавиш 
char flScanKbd; // Признак того, что в данный момент идет сканирование клавиатуры, состояние не менять.
char CountKeys;       // Переменная для защиты от дребезга
char CountState = 0; // Флаг того, что сохраняем состояние процесса (каждое значение - это полсекунды)
char DispDopInfo = 0; // Флаг отображения дополнительной информации (через раз)
// 1 - смените емкость
// 2 - емкость с головами.
// 3 - низкое напряжение для поддержания мощности


#define MAX_KLP 5       // Количество клапанов, которыми надо управлять по ШИМ. 

#define PIN_KLP_BEG 22  // Начальный пин для управления клапанами 

#define KLP_NPG  0      // Номер клапана для управления НПГ (при дистилляции) 
#define KLP_VODA 1      // Номер клапана для управления общей подачей воды в систему
#define KLP_DEFL 2      // Номер клапана для подачи воды в дефлегматор
#define KLP_DEFL_D 2    // Номер клапана для подачи воды в дефлегматор (при дистилляции с дефлегматором с паровым отбором)
#define KLP_GLV_HVS  3  // Номер клапана отбора головных и хвостовых фракций
#define KLP_BARDA  3  // Номер клапана слива барды
#define KLP_SR   4      // Номер клапана отбора ректификата
#define KLP_HLD  3      // Номер клапана холодильника (для дистилляции)

#define TEMP_KUB  0      // Номер датчика  термометра в кубе
#define TEMP_RK20 1      // Номер датчика термометра в РК 20 см от насадки
#define TEMP_TSA  2      // Номер термометра в трубке связи с атмосферой
#define MAX_TEMP_TSA 650 // Максимальная температура в датчике ТСА
#define TEMP_DEFL 1      // Номер датчика  термометра в дефлегматоре
#define TEMP_TERMOSTAT 0 // Номер датчика  термометра термостата
#define TEMP_RAZVAR 0    // Номер датчика  термометра для разваривания зерновых


#if SIMPLED_VERSION>=1
#define USE_LCD_KEYPAD_SHIELD 1  // 1 - использовать стандартный шильд с кнопкми ардуино, 0 - не использовать
// Пятая версия это почти нулева
#undef PIN_MPX5010 A9      // Пин датчика давления MPX5010DP
#if SIMPLED_VERSION!=5 && SIMPLED_VERSION!=6 && SIMPLED_VERSION!=8 && SIMPLED_VERSION!=9
#define PEREGREV_ON 0  // Не используем защиту клапанов от перегрева
#define PER_KLP_OPEN  100 // Клапана на воду постоянно открыты
#define PER_KLP_CLOSE 0  // из контанты NAPR_PEREGREV 150 
#define USE_ALARM_UROVEN 0  // Нужно ли использовать датчик уровня в приемной емкости ардуино
#define USE_ALARM_VODA   0  // Нужно ли использовать датчик разлития воды ардуино
#define UROVEN_ALARM 1        // Датчик уровня переводим в цифровой режим
#endif

#define USE_GAS_SENSOR 0        // Пин для анализа датчика загазованности (спирта)
#define UROVEN_GAS_SENSOR 1    // уровень газа переводим в цифровой режим

#if SIMPLED_VERSION!=6
#undef NPG_UROVEN_PIN A3         // Отключаем датчик НПГ елси не SIMPLED 6
#endif

#define USE_ASC712 1        // Надо ли исполозовать датчик тока

#endif

// Версия урощена 2 - то же, то упрощенная версия, но с цифровыми датчиками уровня голов, спирта, разлития воды
#if SIMPLED_VERSION==2
#define USE_ALARM_UROVEN 1  // Нужно ли использовать датчик уровня в приемной емкости ардуино 
// 2, нужно использовать как признак стопа ректификации.
#define USE_ALARM_VODA   1  // Нужно ли использовать датчик разлития воды ардуино

#endif

#if SIMPLED_VERSION==3
#define USE_ALARM_UROVEN 2  // Нужно ли использовать датчик уровня в приемной емкости ардуино 2 - датчик используется как уровень при котором останавливается отбор, но не останавливается ректификация
#define USE_ALARM_VODA   0  // Нужно ли использовать датчик разлития воды ардуино
#define KLP_HIGH 0              // В простой версии 3 реле с низким уровнем включения
#endif

#if SIMPLED_VERSION==4
#define USE_ALARM_UROVEN 2  // Нужно ли использовать датчик уровня в приемной емкости ардуино 2 - датчик используется как уровень при котором останавливается отбор, но не останавливается ректификация
#define USE_ALARM_VODA   0  // Нужно ли использовать датчик разлития воды ардуино
#define KLP_HIGH 0              // В простой версии 3 реле с низким уровнем включения
#define USE_ASC712 0        // Надо ли исполозовать датчик тока
#endif

#if SIMPLED_VERSION==5 || SIMPLED_VERSION==6 || SIMPLED_VERSION==7 || SIMPLED_VERSION==8 || SIMPLED_VERSION==9
#define USE_ALARM_UROVEN 2  // Нужно ли использовать датчик уровня в приемной емкости ардуино 2 - датчик используется как уровень при котором останавливается отбор, но не останавливается ректификация
#define USE_ALARM_VODA   1  // Нужно ли использовать датчик разлития воды ардуино
#define KLP_HIGH 1              // В простой версии 5 вместо реле на клапана используются симисторы.
#define USE_ASC712 0        // Надо ли исполозовать датчик тока
#define PIN_TRIAC  10    // Управление симистором реализовано через PIN 10 (для удобства пайки)
#define PIN_DS18B20 2    // датчики температуры подключены к PIN 2 (для удобства пайки)
#define PIN_MPX5010 A1      // Пин датчика давления MPX5010DP к А1 (для удобства пайки)
#define RELAY_HIGH  0         // Какой сигнал подавать на релейные выходы мешалки и разгона 
#define KLP_HLD     2      // Номер клапана холодильника (для дистилляции), такой же, как и дефлегматор.
#define KLP_DEFL_D  4    // Номер клапана дефлегматора дистиллятора - такой же, как и номер клапана отбора спирта, поскольку клапан отбора спирта не используется при дистилляции.
// Версия Slave-регулятора мощности.
#if SIMPLED_VERSION==7
#define USE_ALARM_UROVEN 0 // Нужно ли использовать датчик уровня в приемной емкости ардуино 2 - датчик используется как уровень при котором останавливается отбор, но не останавливается ректификация
#define USE_ALARM_VODA   0 // Нужно ли использовать датчик разлития воды ардуино
#undef PIN_MPX5010 A1      // Пин датчика давления MPX5010DP к А1 (для удобства пайки)
#define USE_SLAVE  1       // Переводим контроллер в Slave - режим
#endif
// Версия с датчиком тока (в основном это для отладки на моем оборудовании подключил датчик тока на A1)
#if SIMPLED_VERSION==8
#define PIN_READI A4         // Аналоговый Пин для чтения тока 
#define USE_ASC712 1         // Надо ли исполозовать датчик тока
#define PEREGREV_ON 0        // Отключаем защиту от перегрева клапанов.
#define PER_KLP_OPEN  100 // Клапана на воду постоянно открыты
#define PER_KLP_CLOSE 0  // из контанты NAPR_PEREGREV 150 
#endif

#if SIMPLED_VERSION==6 || SIMPLED_VERSION==9 || SIMPLED_VERSION==7 || SIMPLED_VERSION==5
#define PIN_READI A4         // Аналоговый Пин для чтения тока 
//   #define USE_CORR_ASC712 1  // Надо ли использовать датчик тока для вывода фактической среднеквадратичной мощности.
#endif


#endif

#define PIN_SLAVE_0 38
#define PIN_SLAVE_1 39
#define PIN_SLAVE_2 40
#define PIN_SLAVE_3 41


char SlaveON = 0;

OneWire  ds(PIN_DS18B20);  // on pin 37
#define MAX_DS1820 5
unsigned char ds1820_devices;                  // Количество датчиков ds18b20 
unsigned char ds1820_rom_codes[MAX_DS1820][9]; // Коды датчиков ds18b20
char ds1820_popr[MAX_DS1820];                  // Поправки к температуре датчиков

// В этой переменной храним температуру в кубе для 
#define COUNT_CHIM 15
int tempK[COUNT_CHIM] = { 0, 880, 960, 1000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
char CHIM[COUNT_CHIM] = { -1, 68, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// здесь храним количество значений в таблице (Отрицательные значения означают, что колнна находится в режиме само-обучения);
char CntCHIM = -4;
char flPopr; // Флаг поправки означает что в данный момент редактируется, температура или ШИМ 0-температура, 1- ШИМ.
#define MAX_CNT_PAUSE 10
char CntPause = 8;
char tempP[MAX_CNT_PAUSE] = { 35, 45, 50, 58, 64, 70, 71, 110, 0, 0 };           // Температурные паузы в градусах
unsigned char timeP[MAX_CNT_PAUSE] = { 15, 15, 20, 30, 60, 30, 0, 120, 0, 0 };  // Время паузы в минутах (если 0, то это значит ожидаем действия пользователя 

char IncrementCHIM = 5;
char DecrementCHIM = 10;
int TimeAutoIncCHIM = 600;
int TimeRestabKolonna = 1800; // Время если в течении которого колонна не стабилизировалась, считаем новую температуру стабилизации

unsigned int KlOpen[MAX_KLP];  // Время закрытия клапанов (в полупериодах, то есть 100 - это примерно 1 секунда)
unsigned int KlClose[MAX_KLP];// Время открытия клапанов  (в полупериодах,то есть 100 - это примерно 1 секунда)
char KlState[MAX_KLP];         // Состояние клапанов (1 открыт - 0 закрыт) 
unsigned int  KlCount[MAX_KLP]; // Счетчик состояния клапанов
char KlReg[MAX_KLP];         // Режим работы
char KlSelect = 0;  // Выбран режим прибавления - либо время открытия, либо время закрытия - это для ручного управления ШИМом, тестирования и прочего
char KlTek = 0;     // Для отладки - режим какого клапана отображать на дисплее  - это для ручного управления ШИМом, тестирования и прочего .  
char flSyncKLP = 0; // Флаг того, что идет синхронизация клапанов, признак того, что состояние клапанов не менять.  

// Ну это понятно, это подключен LCDs

#if USE_I2C_DISPLAY==0
#if USE_LCD_KEYPAD_SHIELD
// Это пины стандратного шильда, если у Вас другой шильд, то поменять значения.
LiquidCrystal lcd(8, 9, 4, 5, 6, 7);
#else
LiquidCrystal lcd(52,50, 48, 46, 44, 42);
#endif
#else
LiquidCrystal_I2C lcd(0x27,16,2);  // set the LCD address to 0x27 for a 16 chars and 2 line display
#endif

int MaxVolts;
int MaxVoltsOut;

int temps[MAX_DS1820];            // Температура датчиков  
int Maxtemps[MAX_DS1820];           // максимальная Температура датчиков  за процесс.

unsigned char nPopr = 0;                     // Текущий датчик, которому вносится поправка

#define PIN_SOUND 11    // На 11 пине сидит спикер от компа (мощная штука, 15 ом, потребляет 300ма, поэтому ей пока не злоупотребляю, может заменить ее в дальнейшем на Пьезо?)

#define PIN_RZG_ON 30    // Пин для включения режима разгона             (может работать и без него)
#define PIN_ALL_OFF 31  // Пин, при подаче напряжения на который вырыбаеся вообще все (например выключается УЗО) (может работать и без него)
#define PIN_RST_WDT 43  // Пин, на который периодически меняется значение с 0 на 1 (раз в 5 секунд обычно) служит для отслеживаения зависания Ардуины внешним устройством.

char flAllOff;           // Флаг того, что все выключено

unsigned char Counter1 = 0;
long Seconds;   // Текущее состояние времени с начала процесса (не беззнаковое, потому, что есть проверки на <0);
long SecondsEnd;// Время окончания процесса 

char NeedDisplaying;
char flNoPhase = 1;  // Переменная признак отключения фазового управления клапанов (например на период чтения датчиков температуры)
int resultU;

unsigned char StateVolts = 0;  // Состояние вычисление среднеквадратичного 
//0 - надо вычислить - запускается старт, 1 - вычисляется, 2 - вычислено, 3 - идет обработка рузультата
// 4 - Результат обработан, можно вычислять следующий
int index_input = 0; // Текущий размер массива дла расчета среднеквадратичного
int prev_index_input = 0; // Текущий размер массива дла расчета среднеквадратичного
int indexOut = 0;    // Размер для вывода на экран

unsigned char flCrossZero = 0;
//unsigned int VoltsZr;
unsigned long TekPower;
unsigned long TekPowerKLP;
unsigned int TimeOpenTriac = 0;
unsigned int TimeOpenTriacFact = 0;
unsigned int TimeOpenKLP = 0;
unsigned int TicZero; // Количество тиков таймера от нуля до нуля.
//char FirstRun;
// Установка мощности (Пока в виде переменных)

int Power = 3000;       // Номинальная мощность ТЭНов
int FactPower = 0;       // Номинальная мощность ТЭНов
int UstPower;     // Нужно получить мощность от регулятора (текущая мощность)
int R_TEN20;        // Сопротиввление ТЭНов, умноженное на 10;

int UstPowerReg = 500;     // Мощность в режиме регулятора мощности

char flNeedTemp = 0;    // Флаг того, что нужно читать температуру датчиков
char StepOut = 0;       // Признак шага чтения температуры 0 - выдаем команду на запрос температуры
// 1 - читаем температуру

//#define USE_BRESENHAM 0// Надо ли использовать брезинхем для управлением двигателем.

int deltaPower = 0; // Разница мощности при дистилляции с дефлегматором.

unsigned char b_size[3];  // Размер брезинхема
unsigned char b_value[3]; // Текущее значение алгоритма
int b_error[3]; // Переменная
unsigned char b_stepNumber[3]; // Номер шага

void bresenham_Init(char n, unsigned char sz)
{
	b_size[n] = sz;
	b_error[n] = b_size[n] / 2;
	b_stepNumber[n] = 0;
	b_value[n] = 0;
}

boolean bresenham_getNext(char n)
{
	boolean result;
	b_error[n] -= b_value[n];
	if (b_error[n] < 0)
	{
		b_error[n] += b_size[n];
		result = HIGH;
	}
	else
	{
		result = LOW;
	}

	if (++b_stepNumber[n] >= b_size[n]) {
		b_stepNumber[n] = 0;
		b_error[n] = b_size[n] / 2;
	}
	return result;
}

void InitGSM()
{
	Serial2.println("AT");
	delay(500);
	// включаем уведомление о входящих СМС.
	Serial2.println("AT+CNMI=1,1");
	delay(500);
	Serial2.println("ATD 1000");
	delay(500);
}


// Пины, на которых сидят кнопки
#define PIN_SELECT 53
#define PIN_RIGHT 51
#define PIN_LEFT 49
#define PIN_UP 45
#define PIN_DOWN 47

#define PRESS_SELECT digitalRead(PIN_SELECT)==0
#define PRESS_RIGHT  digitalRead(PIN_RIGHT)==0
#define PRESS_LEFT  digitalRead(PIN_LEFT)==0
#define PRESS_UP     digitalRead(PIN_UP)==0
#define PRESS_DOWN   digitalRead(PIN_DOWN)==0

char KeyCode; // Код нажатой клавиши

#if USE_LCD_KEYPAD_SHIELD
#define PRESS_SELECT KeyCode==1
#define PRESS_RIGHT  KeyCode==2
#define PRESS_LEFT   KeyCode==3
#define PRESS_UP     KeyCode==4
#define PRESS_DOWN   KeyCode==5
#endif


#define PIN_ALARM_VODA   A5      // Пин, на котором сидит датчик разлития воды на полу (да какой датчик, два луженых провода).     
#define PIN_ALARM_UROVEN A6      // Пин, на котором сидит датчик уровня в приемной емкости (да какой датчик, два луженых провода).
unsigned char CountAlarmVoda = 0;          // Счетчик срабатываний датчика (если сработал три раза, тогда тревога)
unsigned char CountAlarmUroven = 0;        // Счетчик срабатываний датчика (если сработал три раза, тогда тревога)
char CountGasSensor = 0;          // Счетчик срабатываний датчика паров спирта (если сработал три раза, тогда тревога)

#define PIN_TERMOSTAT_ON  28    // Пин термостата, который включается при превышении температуры 
#define PIN_TERMOSTAT_OFF 29    // Пин термостата, который отключается при превышении температуры 

unsigned int BeepTime;
char StateNPG = 0; // Состояние автомата обработки НПГ
// 0 - не запускался
// 1 - инициализируется (наполнение)
// 2 - рабочий режим
// 3 - режим одного уровня тревоги (один раз считан нижний или верхний уровень)

int U_VODA = 0, U_UROVEN = 0, U_GAS = 0, U_NPG = 0, U_GLV = 0; // Уровни воды, газа, НПГ, голов


char NpgDt;// 4- нет сработки датчика 1 - нижний уровень, 2 - рабочий, 3-верхний

void ReadStateDtNPG()
{

#ifdef NPG_UROVEN_PIN   
	U_NPG = analogRead(NPG_UROVEN_PIN);
	// Подтяджка - 10 ком, защита -330 ом, опорное, 2.56, замыкание - 59, резистор 1.1К - 242, 2.2К - 399, 3,3К - 521
	// Подтяджка - 10 ком, защита -330 ом, опорное, 5Вольт, замыкание - 30, резистор 1.1К - 128, 2.2К - 226, 3,3К - 266
	if (U_NPG >= 80) NpgDt = 1;  // Нижний уровень
	if (U_NPG >= 180) NpgDt = 2;  // Рабочий уровень
	if (U_NPG >= 240) NpgDt = 3;  // Верхний уровень
	if (U_NPG >= 500) NpgDt = 4; // Нет сработки

	// Если находимся в режиме аварии, состояние НПГ всегда нет сработки
	if (IspReg > 240) StateNPG = 2;
#endif
}

void ProcessNPG()
{

#ifndef NPG_UROVEN_PIN
	StateNPG=2;
	return;
#else  
	ReadStateDtNPG();
#endif
	switch (StateNPG)
	{
	case 0:// НПГ не запущен
		if (NpgDt == 1) // Если сработка нижнего уровня, то тогда НПГ надо наполнить.
		{
			StateNPG = 1;
			break;
		}
		StateNPG = 2;
		break;
	case 1:// Инициализация НПГ - наполнение
		KlOpen[KLP_NPG] = PER_KLP_OPEN;
		KlClose[KLP_NPG] = PER_KLP_CLOSE;
		if (NpgDt == 2 || NpgDt == 3) // Дошли до рабочего уровня или до переполнения, тогда переходим в рабочий режим.
		{
#ifdef TEST
			sprintf(my_tx_buffer,"NAPOLN NPG=%i NpgDt=%i",U_NPG,NpgDt);
			Serial1.println(my_tx_buffer);
#endif      

			// Повторное чтение для подтверждения датчика 
			ReadStateDtNPG();
			if (NpgDt == 2 || NpgDt == 3)  StateNPG = 4; // Переводим в режим однократной сработки, если прошло подтверждение
		}
		break;
	case 2:// НПГ работает в штатном режиме.
		if (NpgDt == 1 || NpgDt == 3)
		{
#ifdef TEST
			sprintf(my_tx_buffer,"Alarm NPG=%i NpgDt=%i",U_NPG,NpgDt);
			Serial1.println(my_tx_buffer);
#endif      
			// Повторное чтение для подтверждения датчика 
			ReadStateDtNPG();
			if (NpgDt == 1 || NpgDt == 3) StateNPG = 3; // Переводим в режим однократной сработки аварии, если прошло подтверждение
			countAlrmNPG = 1;
		}

		if (NpgDt == 2)
		{
			// Сработка рабочего уровня НПГ
			KlOpen[KLP_NPG] = PER_KLP_OPEN;
			KlClose[KLP_NPG] = PER_KLP_CLOSE;
			countAlrmNPG = 0;

		}

		if (NpgDt == 4) // Нет никакой сработки - отключаем подачу воды
		{
			// Сработка рабочего уровня НПГ
			KlOpen[KLP_NPG] = 0;
			KlClose[KLP_NPG] = 10;
			countAlrmNPG = 0;
		}
		break;
	case 3:  // Была однократная сработка датчиков осушения или переполнения

		if (NpgDt == 1)
		{
			countAlrmNPG++;
			ReadStateDtNPG();
#ifndef TEST
#ifndef DEBUG
			if (countAlrmNPG > MAX_COUNT_NPG_ALARM)
			{
				IspReg = 253;      // Переводим контроллер в режим тревоги по осушению НПГ
			}
#endif
#endif

#ifdef TEST
			sprintf(my_tx_buffer,"Alarm pNPG=%i NpgDt=%i",U_NPG,NpgDt);
			Serial1.println(my_tx_buffer);
#endif      
			break;
		}
		if (NpgDt == 3)
		{
			countAlrmNPG++;
			ReadStateDtNPG();
			// Сработка верхнего уровня НПГ, исклчение - переполнение НПГ.
#ifndef TEST
#ifndef DEBUG
			IspReg = 254;      // Переводим контроллер в режим тревоги по осушению НПГ
#endif
#endif

#ifdef TEST
			sprintf(my_tx_buffer,"Alarm pNPG=%i NpgDt=%i",U_NPG,NpgDt);
			Serial1.println(my_tx_buffer);
#endif      
			break;
		}
		StateNPG = 2; // Если тревога не подтвердилась, переходим в обычный ражим.
		countAlrmNPG = 0;
		break;

	case 4:// При наполнении НПГ была однократная сработка датчиков уровня или переполнения

		// Если подтверждаестся повторная сработка датчика, то токда считаем НПГ переведенным в рабочее состояние
		if (NpgDt == 2 || NpgDt == 3) // Дошли до рабочего уровня или до переполнения, тогда переходим в рабочий режим.
		{
#ifdef TEST
			sprintf(my_tx_buffer,"NAPOLN pNPG=%i NpgDt=%i",U_NPG,NpgDt);
			Serial1.println(my_tx_buffer);
#endif      
			StateNPG = 2; // Переводим НПГ в рабочее состояние.
		}
		break;
	}
}

// Функция устанавливает пищалку на заданное время (в 1/125 секунды), то есть 125-это одна секунда.
void my_beep(unsigned int mBeepTime)
{
	analogWrite(PIN_SOUND, 127);
	BeepTime = mBeepTime;
}

// Функция расчета квадратного корня.
// Значения корней от 0 до 90 и от 256 до 512 считаются по очень приблизительным формулам, поскольку такое значение среднеквадратичного в нормальной сети 220 вольт недопустимо
// Больше 512 значение не определено.
int my_sqrt(unsigned long tsQT)
{
	char i;
	unsigned int sQT; // Временная переменная, чтобы поменьше сравнивать 4-битных чисел.
	int res = 666;
	// Если попадаем в диапазон
	if (tsQT < tableSQ[0])
	{
		// Если меньше минимального значения, тогда расчет по крайне приближенной формуле
		res = tsQT*tableSQRT[0] / tableSQ[0];
	}
	else
		if (tsQT <= tableSQ[MAX_TABLE_SQRT - 1])
		{
			sQT = tsQT;
			for (i = 1; i < MAX_TABLE_SQRT; i++)
			{

				if (tableSQ[i - 1] <= sQT && tableSQ[i] >= sQT)
				{
					if (tableSQ[i - 1] == sQT) res = tableSQRT[i - 1]; // На крайних значениях берем готовые цифры
					else
						if (tableSQ[i] == sQT) res = tableSQRT[i]; // На крайних значениях берем готовые цифры
						else res = (sQT - tableSQ[i - 1])*(tableSQRT[i] - tableSQRT[i - 1]) / (tableSQ[i] - tableSQ[i - 1]) + tableSQRT[i - 1] + 1; // На промежуточных вычисляем.

						return res;
				}
			}
		}
		else
		{
			// Если больше максимального считаем по крайне приближенной формуле, исходя из максимума значений в 512
			res = (tsQT - tableSQ[MAX_TABLE_SQRT - 1])*(512 - tableSQRT[MAX_TABLE_SQRT - 1]) / (262144 - tableSQ[MAX_TABLE_SQRT - 1]) + tableSQRT[MAX_TABLE_SQRT - 1] + 1;
		}

	return res;
}

void setup()
{
	unsigned char i;
	// set up the LCD's number of columns and rows: 

	Serial1.begin(9600);
	Serial2.begin(9600);

	StateVolts = 6;

#if USE_I2C_DISPLAY==0
	lcd.begin(16, 2);
#else
	lcd.init();
	lcd.backlight();
#endif

	// Print a message to the LCD.
	//  my_lcdprint("hello, world!");
	//  analogReference(DEFAULT);

	//  #if USE_LCD_KEYPAD_SHIELD==0
	//    analogReference(INTERNAL2V56);
	//  #else
	// теперь опорно напряжение всегда делаем +5В, чтобы работа программы была одинаковой, как с использованием дисплей шильда, так и без него
	analogReference(DEFAULT);
	// #endif

	pinMode(PIN_TRIAC, OUTPUT);
	pinMode(PIN_ALL_OFF, OUTPUT);
	pinMode(PIN_RST_WDT, OUTPUT);

	pinMode(PIN_RZG_ON, OUTPUT);
	digitalWrite(PIN_RZG_ON, !RELAY_HIGH);

	pinMode(PIN_NASOS_NBK, OUTPUT);
	pinMode(PIN_MIXER, OUTPUT);
	digitalWrite(PIN_MIXER, !RELAY_HIGH);
	digitalWrite(PIN_NASOS_NBK, LOW);
	pinMode(PIN_TERMOSTAT_ON, OUTPUT);
	pinMode(PIN_TERMOSTAT_OFF, OUTPUT);

	if (UROVEN_ALARM == 1)
	{
		pinMode(PIN_ALARM_VODA, INPUT);
		pinMode(PIN_ALARM_UROVEN, INPUT);
	}


	if (UrovenProvodimostSR == 1)
	{
		pinMode(PIN_PROVODIMOST_SR, INPUT);
	}

#ifdef ULTRASONIC_PIN
	pinMode(ULTRASONIC_PIN, OUTPUT);
	pinMode(ULTRASONIC_PIN+1, INPUT);
#endif
	//  digitalWrite(29, HIGH);  
	//  pinMode(22, OUTPUT);
	//  digitalWrite(22, HIGH);  
	//  pinMode(25, OUTPUT);
	//  digitalWrite(25, HIGH);  
	//  pinMode(26, OUTPUT);
	//  digitalWrite(26, HIGH);  
	//  pinMode(24, OUTPUT);
	//  digitalWrite(24, HIGH);  
	//  pinMode(NPG_UROVEN_PIN, INPUT);
	//  digitalWrite(NPG_UROVEN_PIN, HIGH);  



	pinMode(PIN_SELECT, INPUT);           // назначить выводу порт ввода
	digitalWrite(PIN_SELECT, HIGH);       // включить подтягивающий резистор

	pinMode(PIN_RIGHT, INPUT);           // назначить выводу порт ввода
	digitalWrite(PIN_RIGHT, HIGH);       // включить подтягивающий резистор

	pinMode(PIN_LEFT, INPUT);           // назначить выводу порт ввода
	digitalWrite(PIN_LEFT, HIGH);       // включить подтягивающий резистор

	pinMode(PIN_UP, INPUT);           // назначить выводу порт ввода
	digitalWrite(PIN_UP, HIGH);       // включить подтягивающий резистор

	pinMode(PIN_DOWN, INPUT);           // назначить выводу порт ввода
	digitalWrite(PIN_DOWN, HIGH);       // включить подтягивающий резистор


	// Проходим по клапанам и устанавливаем им ШИМ и настраиваем пины
	for (i = 0; i < MAX_KLP; i++)
	{
		pinMode(PIN_KLP_BEG + i, OUTPUT);
		digitalWrite(PIN_KLP_BEG + i, !KLP_HIGH);
		KlOpen[i] = 0;
		KlClose[i] = 10;
		KlState[i] = 0;          // Начальное состояние - клапан закрыт, счетчик 0
		KlCount[i] = 0;
	}

	//  #if USE_ASC712==0
	//  attachInterrupt(1, zero_crosss_int, RISING);  // Устанавливаем на 1-е прерывание функцию (это pin 3) обработку от детектора нулюя сетевого напряжения
	//  #else
	// Сейчас всегда устанавливаем обработку на переход с ненуля на ноль, чтобы было немного больше времени на программу в прерывании нуля.
	attachInterrupt(1, zero_crosss_int, FALLING);  // Устанавливаем на 1-е прерывание функцию (это pin 3) обработку от детектора нулюя сетевого напряжения
	//  #endif
	//  attachInterrupt(0, zero_crosss_trans, RISING);  // Устанавливаем на 0-е прерывание функцию (это pin 2) обработку от детектора нуля трансформатора.

#ifdef FLOW_DETECT_ON
	attachInterrupt(3, flow_crosss_int, FALLING);  // Устанавливаем на 1-е прерывание функцию (это pin 3) обработку от детектора нулюя сетевого напряжения
#endif


	// Таймер 2 используется для подсчета числа секунд и, возможно, программного небыстрого ШИМа
	// Прерываение по этому таймеру будет вызываться 125 раз в секунду.
	// Timer/Counter 2 initialization
	// Clock source: System Clock
	// Clock value: 62,500 kHz
	// Mode: Normal top=0xFF
	// OC2A output: Disconnected
	// OC2B output: Disconnected
	TCCR2A = 0x00;
	TCCR2B = 0x07;
	TCNT2 = 0x00;
	OCR2A = 0x7D;
	OCR2B = 0x00;
	//  // Timer/Counter 1 Interrupt(s) initialization
	TIMSK2 = 0x02;


	// Таймер 3 будет использоваться для такой, обычно очень несвойственной для него процедуры, как "замена" аппаратного прерывания АЦП.
	// (сейчас таймер свободен, так что может быть задействован для других целей)
	// Timer/Counter 3 initialization
	// Clock source: System Clock
	// Clock value: 250,000 kHz
	// Mode: Normal top=0xFFFF
	// OC3A output: Discon.
	// OC3B output: Discon.
	// OC3C output: Discon.
	// Noise Canceler: Off
	// Input Capture on Falling Edge
	// Timer3 Overflow Interrupt: Off
	// Input Capture Interrupt: Off
	// Compare A Match Interrupt: On
	// Compare B Match Interrupt: Off
	// Compare C Match Interrupt: Off
	TCCR3A = 0x00;
	TCCR3B = 0x03;
	TCNT3H = 0x00;
	TCNT3L = 0x00;
	ICR3H = 0x00;
	ICR3L = 0x00;

	OCR3AH = 0;
	OCR3AL = 0x7;

	OCR3BH = 0x00;
	OCR3BL = 0x00;
	OCR3CH = 0x00;
	OCR3CL = 0x00;
	// Timer/Counter 3 Interrupt(s) initialization
	TIMSK3 = 0x02;

	// Таймер 4 будет использоваться для подсчета числа тиков при вызове АЦП в расчете среднеквадратичного 
	// (поскольку непонятно, чего и сколько это занимает в Ардуино - исходный код разбирать неохота)
	// Timer/Counter 4 initialization
	// Clock source: System Clock
	// Clock value: 250,000 kHz
	// Mode: Normal top=0xFFFF
	// OC4A output: Discon.
	// OC4B output: Discon.
	// OC4C output: Discon.
	// Noise Canceler: Off
	// Input Capture on Falling Edge
	// Timer4 Overflow Interrupt: Off
	// Input Capture Interrupt: Off
	// Compare A Match Interrupt: Off
	// Compare B Match Interrupt: Off
	// Compare C Match Interrupt: Off
	TCCR4A = 0x00;
	TCCR4B = 0x03;
	TCNT4H = 0x00;
	TCNT4L = 0x00;
	ICR4H = 0x00;
	ICR4L = 0x00;
	OCR4AH = 0x00;
	OCR4AL = 0x00;
	OCR4BH = 0x00;
	OCR4BL = 0x00;
	OCR4CH = 0x00;
	OCR4CL = 0x00;
	// Timer/Counter 4 Interrupt(s) initialization
	TIMSK4 = 0x00;


	// Таймер 5 будет использоваться для управления симистором регулятора мощности по прерыванию COMPA.
	// Таймер 5 будет использоваться для управления симистороми клапанов по прерыванию COMPB.
	// Таймер 5 будет использоваться для управления симистором регулятора оборотов двигателя прерыванию COMPС.
	// Timer/Counter 5 initialization
	// Clock source: System Clock
	// Clock source: System Clock
	// Clock value: 250,000 kHz
	// Mode: Normal top=0xFFFF
	// OC5A output: Discon.
	// OC5B output: Discon.
	// OC5C output: Discon.
	// Noise Canceler: Off
	// Input Capture on Falling Edge
	// Timer5 Overflow Interrupt: Off
	// Input Capture Interrupt: Off
	// Compare A Match Interrupt: On
	// Compare B Match Interrupt: On
	// Compare C Match Interrupt: On

	TCCR5A = 0x00;
	TCCR5B = 0x03;
	TCNT5H = 0x00;
	TCNT5L = 0x00;
	ICR5H = 0x00;
	ICR5L = 0x00;
	OCR5AH = 0x00;
	OCR5AL = 0x02;
	OCR5BH = 0x00;
	OCR5BL = 0x00;
	OCR5CH = 0x00;
	OCR5CL = 0x00;
	// Timer/Counter 5 Interrupt(s) initialization
	//  TIMSK5=0x06;
	TIMSK5 = 0x0E;// Инициализируем прерывания таймера


	//  TekPower=(unsigned long) UstPower*220*220/ Power;

	ds1820_devices = 0;
	while (ds.search(ds1820_rom_codes[ds1820_devices])) {
		ds1820_devices++;
		if (ds1820_devices >= MAX_DS1820) break;
	}
	ds.reset_search();
	lcd.clear();
#ifdef DEBUG
	ds1820_devices=3;
	sprintf(lcd_buffer,"debug=%u",ds1820_devices); //запись в буфер текста и значений температуры в подготовленном
#else
	sprintf(lcd_buffer, "ds18B20Count=%u", ds1820_devices); //запись в буфер текста и значений температуры в подготовленном
#endif
	my_lcdprint(lcd_buffer);
	sprintf(lcd_buffer, "U,V,P,G=%i,%i,%i,%i ", USE_ALARM_UROVEN, USE_ALARM_VODA, UrovenProvodimostSR, USE_GAS_SENSOR); //запись в буфер текста и значений температуры в подготовленном
	lcd.setCursor(0, 1);
	my_lcdprint(lcd_buffer);
	delay(2000);
	lcd.clear();
	sprintf(lcd_buffer, "%s  RWR=%i", my_version, PR_REWRITE_EEPROM); //запись в буфер текста и значений температуры в подготовленном
	my_lcdprint(lcd_buffer);
	lcd.setCursor(0, 1);
#ifndef USE_SLAVE
	sprintf(lcd_buffer, "Simpled=%u ", SIMPLED_VERSION); //запись в буфер текста и значений температуры в подготовленном
#else
	sprintf(lcd_buffer,"Simpled=%u Slave",SIMPLED_VERSION); //запись в буфер текста и значений температуры в подготовленном
#endif
	my_lcdprint(lcd_buffer);
	delay(1000);
	flNeedTemp = 0;
	StepOut = 0;

	// Читаем ранее сохраненные значения из энергонезависимой памяти.
	if (EEPROM.read(0) != PR_REWRITE_EEPROM)
	{
		writeEEPROM();
	}




	for (i = 0; i < ds1820_devices; i++)
	{
		temps[i] = 0;
		Maxtemps[i] = 0;
		ds1820_popr[i] = 0;                  // Поправки к температуре датчиков устанавливаем в ноль (в дальнейшем они сами считаются из eeprom, если были ранее записаны).
		// Выдадим номера датчиков.
		if (FlToUSART)
		{
			sprintf(my_tx_buffer, "ds18b20\t%1X\t%02X%02X%02X%02X%02X%02X%02X%02X", i, ds1820_rom_codes[i][0], ds1820_rom_codes[i][1], ds1820_rom_codes[i][2],
				ds1820_rom_codes[i][3], ds1820_rom_codes[i][4], ds1820_rom_codes[i][5], ds1820_rom_codes[i][6], ds1820_rom_codes[i][7]);
			Serial1.println(my_tx_buffer);
		}
	}

	readEEPROM();

#ifdef USE_SLAVE
	IspReg=103; // Для Slave режима всегда устанавливаем регулятор мощности при перезагрузке
	pinMode(PIN_SLAVE_0, INPUT);
	pinMode(PIN_SLAVE_1, INPUT);
	pinMode(PIN_SLAVE_2, INPUT);
	pinMode(PIN_SLAVE_3, INPUT);
#else
	pinMode(PIN_SLAVE_0, OUTPUT);
	pinMode(PIN_SLAVE_1, OUTPUT);
	pinMode(PIN_SLAVE_2, OUTPUT);
	pinMode(PIN_SLAVE_3, OUTPUT);
	// Отключаем подчиненные контроллеры
	digitalWrite(PIN_SLAVE_0, 0);
	digitalWrite(PIN_SLAVE_1, 0);
	digitalWrite(PIN_SLAVE_2, 0);
	digitalWrite(PIN_SLAVE_3, 0);
#endif


#ifndef DEBUG
	my_beep(10);
#endif
	if (IspReg >= 240) IspReg = 101;
	// Выдаем тестовую команду
	InitGSM();

	if (IspReg >= 250) IspReg = 101;

	GetPhonePDU();
#ifdef DEBUG
	//  Serial1.begin(9600);
	Serial1.println("start debug");
#endif

	CloseAllKLP();
	//  digitalWrite(PIN_REG_ON,LOW);
	digitalWrite(PIN_RZG_ON, !RELAY_HIGH);
	digitalWrite(PIN_ALL_OFF, ALL_OFF_HIGH);
	delay(100);
	digitalWrite(PIN_ALL_OFF, !ALL_OFF_HIGH);
	flAllOff = 0;

	digitalWrite(PIN_TERMOSTAT_ON, LOW);
	digitalWrite(PIN_TERMOSTAT_OFF, LOW);
	UstPower = 0;
	StateNPG = 0;
	StateMachine = 0;

	bresenham_Init(0, 200);
	bresenham_Init(1, 125);
	b_value[0] = 0;

#ifdef TEST
	temps[TEMP_KUB]=799;
	GetCHIMOtbor();
	temps[TEMP_KUB]=880;
	GetCHIMOtbor();
	temps[TEMP_KUB]=890;
	GetCHIMOtbor();
	temps[TEMP_KUB]=900;
	GetCHIMOtbor();
	temps[TEMP_KUB]=960;
	GetCHIMOtbor();
	temps[TEMP_KUB]=980;
	GetCHIMOtbor();
#endif

	// Устанавливаем значение таблицы открытия симистора
	tableT[0] = 2278;// tableK[ 0]= 5;
	tableT[1] = 2215;// tableK[ 1]= 10;
	tableT[2] = 2170;// tableK[ 2]= 15;
	tableT[3] = 2135;// tableK[ 3]= 20;
	tableT[4] = 2106;// tableK[ 4]= 25;
	tableT[5] = 2080;// tableK[ 5]= 30;
	tableT[6] = 2056;// tableK[ 6]= 35;
	tableT[7] = 2035;// tableK[ 7]= 40;
	tableT[8] = 2015;// tableK[ 8]= 45;
	tableT[9] = 1996;// tableK[ 9]= 50;
	tableT[10] = 1979;// tableK[ 10]= 55;
	tableT[11] = 1963;// tableK[ 11]= 60;
	tableT[12] = 1947;// tableK[ 12]= 65;
	tableT[13] = 1932;// tableK[ 13]= 70;
	tableT[14] = 1918;// tableK[ 14]= 75;
	tableT[15] = 1904;// tableK[ 15]= 80;
	tableT[16] = 1891;// tableK[ 16]= 85;
	tableT[17] = 1878;// tableK[ 17]= 90;
	tableT[18] = 1865;// tableK[ 18]= 95;
	tableT[19] = 1853;// tableK[ 19]= 100;
	tableT[20] = 1842;// tableK[ 20]= 105;
	tableT[21] = 1830;// tableK[ 21]= 110;
	tableT[22] = 1819;// tableK[ 22]= 115;
	tableT[23] = 1808;// tableK[ 23]= 120;
	tableT[24] = 1798;// tableK[ 24]= 125;
	tableT[25] = 1787;// tableK[ 25]= 130;
	tableT[26] = 1777;// tableK[ 26]= 135;
	tableT[27] = 1767;// tableK[ 27]= 140;
	tableT[28] = 1757;// tableK[ 28]= 145;
	tableT[29] = 1748;// tableK[ 29]= 150;
	tableT[30] = 1738;// tableK[ 30]= 155;
	tableT[31] = 1729;// tableK[ 31]= 160;
	tableT[32] = 1720;// tableK[ 32]= 165;
	tableT[33] = 1711;// tableK[ 33]= 170;
	tableT[34] = 1702;// tableK[ 34]= 175;
	tableT[35] = 1693;// tableK[ 35]= 180;
	tableT[36] = 1685;// tableK[ 36]= 185;
	tableT[37] = 1676;// tableK[ 37]= 190;
	tableT[38] = 1668;// tableK[ 38]= 195;
	tableT[39] = 1660;// tableK[ 39]= 200;
	tableT[40] = 1651;// tableK[ 40]= 205;
	tableT[41] = 1643;// tableK[ 41]= 210;
	tableT[42] = 1635;// tableK[ 42]= 215;
	tableT[43] = 1627;// tableK[ 43]= 220;
	tableT[44] = 1619;// tableK[ 44]= 225;
	tableT[45] = 1612;// tableK[ 45]= 230;
	tableT[46] = 1604;// tableK[ 46]= 235;
	tableT[47] = 1596;// tableK[ 47]= 240;
	tableT[48] = 1589;// tableK[ 48]= 245;
	tableT[49] = 1581;// tableK[ 49]= 250;
	tableT[50] = 1574;// tableK[ 50]= 255;
	tableT[51] = 1566;// tableK[ 51]= 260;
	tableT[52] = 1559;// tableK[ 52]= 265;
	tableT[53] = 1552;// tableK[ 53]= 270;
	tableT[54] = 1545;// tableK[ 54]= 275;
	tableT[55] = 1537;// tableK[ 55]= 280;
	tableT[56] = 1530;// tableK[ 56]= 285;
	tableT[57] = 1523;// tableK[ 57]= 290;
	tableT[58] = 1516;// tableK[ 58]= 295;
	tableT[59] = 1509;// tableK[ 59]= 300;
	tableT[60] = 1502;// tableK[ 60]= 305;
	tableT[61] = 1495;// tableK[ 61]= 310;
	tableT[62] = 1488;// tableK[ 62]= 315;
	tableT[63] = 1482;// tableK[ 63]= 320;
	tableT[64] = 1475;// tableK[ 64]= 325;
	tableT[65] = 1468;// tableK[ 65]= 330;
	tableT[66] = 1461;// tableK[ 66]= 335;
	tableT[67] = 1455;// tableK[ 67]= 340;
	tableT[68] = 1448;// tableK[ 68]= 345;
	tableT[69] = 1441;// tableK[ 69]= 350;
	tableT[70] = 1435;// tableK[ 70]= 355;
	tableT[71] = 1428;// tableK[ 71]= 360;
	tableT[72] = 1422;// tableK[ 72]= 365;
	tableT[73] = 1415;// tableK[ 73]= 370;
	tableT[74] = 1408;// tableK[ 74]= 375;
	tableT[75] = 1402;// tableK[ 75]= 380;
	tableT[76] = 1396;// tableK[ 76]= 385;
	tableT[77] = 1389;// tableK[ 77]= 390;
	tableT[78] = 1383;// tableK[ 78]= 395;
	tableT[79] = 1376;// tableK[ 79]= 400;
	tableT[80] = 1370;// tableK[ 80]= 405;
	tableT[81] = 1363;// tableK[ 81]= 410;
	tableT[82] = 1357;// tableK[ 82]= 415;
	tableT[83] = 1351;// tableK[ 83]= 420;
	tableT[84] = 1344;// tableK[ 84]= 425;
	tableT[85] = 1338;// tableK[ 85]= 430;
	tableT[86] = 1332;// tableK[ 86]= 435;
	tableT[87] = 1325;// tableK[ 87]= 440;
	tableT[88] = 1319;// tableK[ 88]= 445;
	tableT[89] = 1313;// tableK[ 89]= 450;
	tableT[90] = 1306;// tableK[ 90]= 455;
	tableT[91] = 1300;// tableK[ 91]= 460;
	tableT[92] = 1294;// tableK[ 92]= 465;
	tableT[93] = 1288;// tableK[ 93]= 470;
	tableT[94] = 1281;// tableK[ 94]= 475;
	tableT[95] = 1275;// tableK[ 95]= 480;
	tableT[96] = 1269;// tableK[ 96]= 485;
	tableT[97] = 1263;// tableK[ 97]= 490;
	tableT[98] = 1256;// tableK[ 98]= 495;
	tableT[99] = 1250;// tableK[ 99]= 500;
	tableT[100] = 1244;// tableK[ 100]= 505;
	tableT[101] = 1238;// tableK[ 101]= 510;
	tableT[102] = 1231;// tableK[ 102]= 515;
	tableT[103] = 1225;// tableK[ 103]= 520;
	tableT[104] = 1219;// tableK[ 104]= 525;
	tableT[105] = 1213;// tableK[ 105]= 530;
	tableT[106] = 1206;// tableK[ 106]= 535;
	tableT[107] = 1200;// tableK[ 107]= 540;
	tableT[108] = 1194;// tableK[ 108]= 545;
	tableT[109] = 1187;// tableK[ 109]= 550;
	tableT[110] = 1181;// tableK[ 110]= 555;
	tableT[111] = 1175;// tableK[ 111]= 560;
	tableT[112] = 1169;// tableK[ 112]= 565;
	tableT[113] = 1162;// tableK[ 113]= 570;
	tableT[114] = 1156;// tableK[ 114]= 575;
	tableT[115] = 1150;// tableK[ 115]= 580;
	tableT[116] = 1143;// tableK[ 116]= 585;
	tableT[117] = 1137;// tableK[ 117]= 590;
	tableT[118] = 1130;// tableK[ 118]= 595;
	tableT[119] = 1124;// tableK[ 119]= 600;
	tableT[120] = 1118;// tableK[ 120]= 605;
	tableT[121] = 1111;// tableK[ 121]= 610;
	tableT[122] = 1105;// tableK[ 122]= 615;
	tableT[123] = 1098;// tableK[ 123]= 620;
	tableT[124] = 1092;// tableK[ 124]= 625;
	tableT[125] = 1085;// tableK[ 125]= 630;
	tableT[126] = 1079;// tableK[ 126]= 635;
	tableT[127] = 1072;// tableK[ 127]= 640;
	tableT[128] = 1066;// tableK[ 128]= 645;
	tableT[129] = 1059;// tableK[ 129]= 650;
	tableT[130] = 1052;// tableK[ 130]= 655;
	tableT[131] = 1046;// tableK[ 131]= 660;
	tableT[132] = 1039;// tableK[ 132]= 665;
	tableT[133] = 1032;// tableK[ 133]= 670;
	tableT[134] = 1026;// tableK[ 134]= 675;
	tableT[135] = 1019;// tableK[ 135]= 680;
	tableT[136] = 1012;// tableK[ 136]= 685;
	tableT[137] = 1005;// tableK[ 137]= 690;
	tableT[138] = 998;// tableK[ 138]= 695;
	tableT[139] = 991;// tableK[ 139]= 700;
	tableT[140] = 984;// tableK[ 140]= 705;
	tableT[141] = 977;// tableK[ 141]= 710;
	tableT[142] = 970;// tableK[ 142]= 715;
	tableT[143] = 963;// tableK[ 143]= 720;
	tableT[144] = 956;// tableK[ 144]= 725;
	tableT[145] = 949;// tableK[ 145]= 730;
	tableT[146] = 941;// tableK[ 146]= 735;
	tableT[147] = 934;// tableK[ 147]= 740;
	tableT[148] = 927;// tableK[ 148]= 745;
	tableT[149] = 919;// tableK[ 149]= 750;
	tableT[150] = 912;// tableK[ 150]= 755;
	tableT[151] = 904;// tableK[ 151]= 760;
	tableT[152] = 897;// tableK[ 152]= 765;
	tableT[153] = 889;// tableK[ 153]= 770;
	tableT[154] = 881;// tableK[ 154]= 775;
	tableT[155] = 873;// tableK[ 155]= 780;
	tableT[156] = 865;// tableK[ 156]= 785;
	tableT[157] = 857;// tableK[ 157]= 790;
	tableT[158] = 849;// tableK[ 158]= 795;
	tableT[159] = 841;// tableK[ 159]= 800;
	tableT[160] = 833;// tableK[ 160]= 805;
	tableT[161] = 824;// tableK[ 161]= 810;
	tableT[162] = 816;// tableK[ 162]= 815;
	tableT[163] = 807;// tableK[ 163]= 820;
	tableT[164] = 799;// tableK[ 164]= 825;
	tableT[165] = 790;// tableK[ 165]= 830;
	tableT[166] = 781;// tableK[ 166]= 835;
	tableT[167] = 772;// tableK[ 167]= 840;
	tableT[168] = 762;// tableK[ 168]= 845;
	tableT[169] = 753;// tableK[ 169]= 850;
	tableT[170] = 743;// tableK[ 170]= 855;
	tableT[171] = 734;// tableK[ 171]= 860;
	tableT[172] = 724;// tableK[ 172]= 865;
	tableT[173] = 714;// tableK[ 173]= 870;
	tableT[174] = 703;// tableK[ 174]= 875;
	tableT[175] = 693;// tableK[ 175]= 880;
	tableT[176] = 682;// tableK[ 176]= 885;
	tableT[177] = 671;// tableK[ 177]= 890;
	tableT[178] = 660;// tableK[ 178]= 895;
	tableT[179] = 648;// tableK[ 179]= 900;
	tableT[180] = 636;// tableK[ 180]= 905;
	tableT[181] = 624;// tableK[ 181]= 910;
	tableT[182] = 611;// tableK[ 182]= 915;
	tableT[183] = 598;// tableK[ 183]= 920;
	tableT[184] = 584;// tableK[ 184]= 925;
	tableT[185] = 570;// tableK[ 185]= 930;
	tableT[186] = 555;// tableK[ 186]= 935;
	tableT[187] = 540;// tableK[ 187]= 940;
	tableT[188] = 523;// tableK[ 188]= 945;
	tableT[189] = 506;// tableK[ 189]= 950;
	tableT[190] = 488;// tableK[ 190]= 955;
	tableT[191] = 468;// tableK[ 191]= 960;
	tableT[192] = 447;// tableK[ 192]= 965;
	tableT[193] = 424;// tableK[ 193]= 970;
	tableT[194] = 399;// tableK[ 194]= 975;
	tableT[195] = 370;// tableK[ 195]= 980;
	tableT[196] = 336;// tableK[ 196]= 985;
	tableT[197] = 294;// tableK[ 197]= 990;
	tableT[198] = 236;// tableK[ 198]= 995;
	tableT[199] = 10;// tableK[ 199]= 1000;

	// Заполняем таблицу квадратов от 90 - минимаальное значени напряжение при котором работает блок питания контролера до
	// 255 - ну просто максимальное среднеквадратичное значение напряжения в сети.
#ifdef TESTRM
	Serial1.println("TABLESQRT");
#endif
	for (i = 0; i < MAX_TABLE_SQRT; i++)
	{
		tableSQRT[i] = (int)i * 5 + 90;
		tableSQ[i] = (unsigned int)tableSQRT[i] * tableSQRT[i];
#ifdef TESTRM
		Serial1.print((unsigned int)i);
		Serial1.write(9);
		Serial1.print((unsigned int)tableSQRT[i]);
		Serial1.write(9);
		Serial1.println((unsigned int)tableSQ[i]);
#endif
	}
#ifdef TESTRM
	Serial1.println("END TABLESQRT");
#endif


#ifdef TESTRM
	//      Serial1.println("TEST MY_SQRT");
	//      int j;
	//
	//      for(j=0;j<=600;j++)
	//      {
	//          Serial1.print((unsigned int) j);
	//          Serial1.write(9);
	//          Serial1.print((unsigned long) j*j );
	//          Serial1.write(9);
	//          Serial1.print((unsigned int) sqrt((unsigned long) j*j) );
	//          Serial1.write(9);
	//          Serial1.print(my_sqrt((unsigned long) j*j) );
	//          Serial1.write(9);
	//          Serial1.println((long)my_sqrt((unsigned long) j*j)- (long) sqrt((unsigned long) j*j));
	//      }
	//      Serial1.println("END TEST MY_SQRT");
#endif
	StateVolts = 0;

}

// Прерывание управления симистором.
ISR(TIMER5_COMPA_vect)
{
#if USE_ASC712==0
	// Включаем симистор
	if (UstPower > 0 && StateMachine < 100)
	{
		// Если НПГ инициализирован, токда подаем питание на ТЭНы, чтобы их не спалить при не заполненном НПГ
		if (StateNPG>1) digitalWrite(PIN_TRIAC, HIGH);
		// ждем 20 мкс и выключаем симистор
	}
	delayMicroseconds(20);
	if (TimeOpenTriacFact != 32000)
	{
		digitalWrite(PIN_TRIAC, LOW);
	}
#else
	// Отключаем симистор только если установленная мощность меньше заданной
	if (UstPower<Power) digitalWrite(PIN_TRIAC, LOW);
#endif
}


// Процедура открывает клапана, которые необходимо открыть.

void OpenKLP()
{
	char i;
	for (i = 0; i < MAX_KLP; i++)
	{ // Если клапан в режиме ШИМ и Состояние клапана включен, то включаем его 
		if (KlReg[i] == 1 && KlState[i] == 1) digitalWrite(PIN_KLP_BEG + i, KLP_HIGH);
	}
}

// Прерывание управления симистором клапанов
ISR(TIMER5_COMPB_vect)
{
#if USE_ASC712==0
	char i;
	for (i = 0; i < MAX_KLP; i++)
	{ // Если клапан в режиме ШИМ и Состояние клапана включен, то включаем его 
		if (KlReg[i] == 1 && KlState[i] == 1) digitalWrite(PIN_KLP_BEG + i, KLP_HIGH);
	}

	if (TimeOpenKLP != 32000 && !flNoPhase) // Если клапана не в режиме максимальной мощности или фазовое управление отключено
	{
		delayMicroseconds(20);

		for (i = 0; i < MAX_KLP; i++)
		{ // Если клапан в режиме ШИМ и Состояние клапана включен, то выключаем его 
			if (KlReg[i] == 1 && KlState[i] == 1) digitalWrite(PIN_KLP_BEG + i, !KLP_HIGH);
		}
	}
	//  digitalWrite(PIN_KLP_BEG+1, HIGH);  
	//  // ждем 20 мкс и выключаем симистор
	//  delayMicroseconds(20);       
	//  digitalWrite(PIN_KLP_BEG+1, LOW);  
#endif
}

// Прерывание управления симистором двигателя
ISR(TIMER5_COMPC_vect)
{
	//  файовое управление двигателем пока не используем
	//  // Включаем симистор, если не используем брезинхема.
	//  if (SpeedNBK>0)
	//  {
	//    // Если НПГ инициализирован, токда подаем питание на ТЭНы, чтобы их не спалить при не заполненном НПГ
	//    digitalWrite(PIN_DVIGATEL, HIGH);  
	//    // ждем 20 мкс и выключаем симистор
	//    delayMicroseconds(20);       
	//  }
	//
	//  digitalWrite(PIN_DVIGATEL, LOW);  
}


char fl_read; // Признак того, что надо считать средреквадратичное

// Прерывание по таймеру 3 для расчета выборки для среднеквадратичного
ISR(TIMER3_COMPA_vect)
{
	// Здесь пока ничего не делаем, освободили один таймер.
	//  // Сбрасываем таймер
	//  TCNT3H=0x00;
	//  TCNT3L=0x00;
}



void ReadAlarm()
{

	ProcessNPG();

	// Если уровень тревоги равен единице, то считаем, что датчик цифровой
	if (USE_ALARM_VODA)
	{
		if (UROVEN_ALARM != 1)  U_VODA = analogRead(PIN_ALARM_VODA);
		else U_VODA = !digitalRead(PIN_ALARM_VODA); // Датчики влажности инверсные, то есть при не сработавшем состоянии у них на выходе 1, при сработке 0

		if (U_VODA >= UROVEN_ALARM)
		{
			CountAlarmVoda++;

#ifdef TEST
			sprintf(my_tx_buffer,"ALARM U_VODA=%i cnt=%i",U_VODA,CountAlarmVoda);
			Serial1.println(my_tx_buffer);
#endif      

			if (CountAlarmVoda > COUNT_ALARM)
			{
				DispDopInfo = 2;
				my_beep(BEEP_LONG); // Сначала пищим, предупреждая о необходимости смены тары
				// По прошествии минуты устанавливаем флаг сработки.
				if (CountAlarmVoda > COUNT_ALARM_VODA)
				{
					DispDopInfo = 0;
#ifndef TEST
#ifndef DEBUG
					IspReg = 250;      // Переводим контроллер в режим тревоги, если не установлен тестовый режим.
#endif
#endif
				}
			}
		}
		else
		{
			if (CountAlarmVoda > COUNT_ALARM)   DispDopInfo = 0;
			CountAlarmVoda = 0;
		}
	}

	if (USE_ALARM_UROVEN)
	{
		if (UROVEN_ALARM != 1)  U_UROVEN = analogRead(PIN_ALARM_UROVEN);
		else U_UROVEN = !digitalRead(PIN_ALARM_UROVEN); // Датчики влажности инверсные, то есть при не сработавшем состоянии у них на выходе 1, при сработке 0
		if (U_UROVEN >= UROVEN_ALARM)
		{
			CountAlarmUroven++;
#ifdef TEST
			sprintf(my_tx_buffer,"ALARM U_UROVEN=%i cnt=%i",U_UROVEN,CountAlarmUroven);
			Serial1.println(my_tx_buffer);
#endif      

			if (CountAlarmUroven > COUNT_ALARM)
			{
				my_beep(BEEP_LONG); // Сначала пищим, предупреждая о необходимости смены тары
				DispDopInfo = 1;
				// По прошествии минуты устанавливаем флаг сработки.
				if (CountAlarmUroven > COUNT_ALARM_UROVEN)
				{
					flAlarmUroven = 1;
					flNeedAnalyse = 1;
					DispDopInfo = 0;
				}
			}
		}
		else
		{
			if (CountAlarmUroven > COUNT_ALARM) DispDopInfo = 0;
			CountAlarmUroven = 0;
		}
	}

	if (USE_GAS_SENSOR)
	{
		if (UROVEN_GAS_SENSOR != 1) U_GAS = analogRead(PIN_GAS_SENSOR);
		else U_GAS = digitalRead(PIN_GAS_SENSOR);

		//      Если датчик еще не прогрелся, то выводим значение времени, оставшееся для прогрева датчика паров спирта
		if (Seconds < TIME_PROGREV_GAS_SENSOR) U_GAS = TIME_PROGREV_GAS_SENSOR - Seconds;
		else
		{

			if (U_GAS >= UROVEN_GAS_SENSOR)
			{
				CountGasSensor++;
#ifdef TEST
				sprintf(my_tx_buffer,"ALARM U_GAS=%i cnt=%i",U_GAS,CountGasSensor);
				Serial1.println(my_tx_buffer);
#endif  

				if (CountGasSensor > COUNT_GAS_SENSOR)
				{
					flNeedAnalyse = 1;
#ifndef TEST
					IspReg = 252;      // Переводим контроллер в режим тревоги, если не установлен тестовый режим.
#endif
				}
			}
			else
				CountGasSensor = 0;
		}
	}


#ifdef PIN_MPX5010
	U_MPX5010 = analogRead(PIN_MPX5010);
	//      U_MPX5010=(U_MPX5010*4)/5-16;
	U_MPX5010 = (U_MPX5010 * 4 - 160) / 5;
	if (FlState != 253) U_MPX5010 = U_MPX5010 + P_MPX5010;
#endif

	if (UrovenProvodimostSR != 0 || IspReg == 112) // Читаем датчик уровня голов, если установлено, что его надо читать, либо если в данный момент используется режим НБК.
	{
		if (UrovenProvodimostSR != 1) U_GLV = analogRead(PIN_PROVODIMOST_SR);
		else U_GLV = !digitalRead(PIN_PROVODIMOST_SR);// Датчики влажности инверсные, то есть при не сработавшем состоянии у них на выходе 1, при сработке 0
	}

	// Для НБК датчик голов служит датчиком заполнения барды.
	if (IspReg == 112) // Если режим - НБК, то открываем слив барды
	{
		if (U_GLV >= UrovenBarda) // Если датчик НБК сработал, то открываем клапан слива барды
		{
			KlOpen[KLP_BARDA] = PER_KLP_OPEN;
			KlClose[KLP_BARDA] = PER_KLP_CLOSE;
		}
		else // Если не сработал, то закрываем.
		{
			KlOpen[KLP_BARDA] = 0;
			KlClose[KLP_BARDA] = 100;
		}
	}


	//   flNeedReadAlarm=false; 
#ifdef ULTRASONIC_PIN

	digitalWrite(ULTRASONIC_PIN, LOW); 
	delayMicroseconds(2); 

	digitalWrite(ULTRASONIC_PIN, HIGH);
	delayMicroseconds(10); 

	digitalWrite(ULTRASONIC_PIN, LOW);

	BegDistance = pulseIn(ULTRASONIC_PIN+1,HIGH,45000);

	BegDistance=BegDistance*100/581;
	//засекаем время в микросекундах
	Distance=BegDistance;
#endif
}


// Прерывание вызывается 125 раз в секунду
ISR(TIMER2_COMPA_vect)
{
	// Сброс таймера
	TCNT2 = 0x00;

	Counter1++;

	// Насосом НБК все равно управляем ( в режим НБК кстати не такие высокие требования к мощности)
	if (SpeedNBK > 0)
	{
		if (timeNBK > 0)
		{
			b_value[1] = SpeedNBK;
			digitalWrite(PIN_NASOS_NBK, bresenham_getNext(1));
		}
	}

	if (StateVolts == 1) return;

	if (Counter1 % 25 == 0)
	{
		Sec5++;
	}



#ifdef DEBUG
	if (Serial1.available()) return;
#endif
	// Сканируем клавиатуру три раза секунду или если находимся не в режиме отображения информации, то постоянно, то есть 125 раз в секунду


	if (BeepTime > 1) BeepTime--;
	else
	{
		if (BeepTime == 1) analogWrite(PIN_SOUND, 0);
		BeepTime = 0;
	}

	//  

	// Следим за защитой от дребезга клавиш
	if (Counter1 % 20 == 0)
	{
		if (CountKeys > 0 && flScanKbd == 0) CountKeys--;
		flNeedScanKbd = 1;

	}

	if (Counter1 == 62)
	{
		NeedDisplaying = true;
		flNeedReadAlarm = true;
		flCrossZero++;
		if (flCrossZero > 80)
		{
			// Если находимся не в режиме термостата или просмотра, и пропадание напряжения не появилось в результате нормального отключения дифавтомата,то переводим в режим тревоги.
			// Если не находимся в режиме тестирования
#ifndef TEST
#ifndef TESTRM
#ifndef DEBUG
			if (IspReg > 102 && (!USE_DIFAVTOMAT || !flAllOff))
			{
				// Выдаем ошибку детектирования нуля.
				IspReg = 249;
			}
#endif
#endif
#endif
			StateVolts = 0;
			flCrossZero = 0;
		}
	}

	//  if (Counter1 % 32 ==0)
	//  {
	//    if (StateVolts==4) 
	//    {
	//      StateVolts=0; // Раз в 1/3 секунды запускаем измерение среднеквадратичного (в дальнейшем можно будет настроить, 
	//      // чтобы оно делалось так часто, насколько позволяют возможности контроллера).
	//      if (CorrectASC712)  flCorrASC712=!flCorrASC712; // Читаем через раз, то мощность, то напряжение если, конечно установлено что надо считать мощность.
	//      
	//    }
	//
	//  }

	if (Counter1 >= 125)
	{
		//    analogWrite(PIN_LIGHT,100);
		zPSOut = zPS;
		zPS = 0;
		if (time1 > 0) time1--;
		else time1 = 0;
		if (time2 > 0) time2--;
		else time2 = 0;
		if (time3 > 0) time3--;
		else time3 = 0;

		if (timeNBK > 0)
		{
			// Задаем скорость насосу. 
			timeNBK--;
		}
		else
		{
			// убираем насос.
			timeNBK = 0;
		}

		if (timeNBK == 0 || SpeedNBK == 0)
		{
			// убираем насос НБК.
			digitalWrite(PIN_NASOS_NBK, 0);
		}

		if (timeMIXER > 0)
		{
			timeMIXER--;
			digitalWrite(PIN_MIXER, RELAY_HIGH);
		}
		else
		{
			timeMIXER = 0;
			digitalWrite(PIN_MIXER, !RELAY_HIGH);
		}

		if (CountState > 0)
		{
			if (CountState == 1) lcd.clear();
			CountState--;
		}
		Seconds++;
		Counter1 = 0;
		NeedDisplaying = true;
		flNeedReadAlarm = true;

		// Если контроллер используется как термостат, или это уже чтение готового результата, или при чтении информации датчиков произошла ошибка то читаем раз в секунду.
		// Или мы сейчас вводим поправки.
		if (IspReg == 102 || StepOut != 0 || FlState == 300 || CntErrDs18)
		{
			flNeedTemp = 1; // Устанавливаем флаг того, что надо читать температуру
		}
		else
		{
			// Иначе запускаем расчет один раз в 5 секунд (чтоб поменьше мограл регулятор мощности).
			if (Seconds % 5 == 0) flNeedTemp = 1;
		}

	}
	// Выполняем процесс.

	if (CountState <= 0 && flScanKbd == 0)
	{
		FlState = 0;
		CountState = 0;
	}

}



// Функция вызывается по прерыванию нуля от нуля сети 220 вольт
boolean br_on; // Признак включения по брезенхему
unsigned char CntPeriodPause = 0; // Число полу-периодов паузы

void zero_crosss_int()  // function to be fired at the zero crossing to dim the light
{
#ifdef DEBUG
	if (Serial1.available()) return;
#endif

	unsigned char i;
	unsigned char flOpenClose;
	zPS++;
	flCrossZero = 0;

	TicZero = (int)TCNT5L | (int)(TCNT5H << 8); // Расчитывааем текущее значение таймера
	// Сбрасываем 5-й таймер.
	TCNT5H = 0x00;
	TCNT5L = 0x00;

	if (StateVolts == 1)
	{
		// Если за полу-период не выбрано допуустимое количество значений, тогда пропускаем эти выборки и пытаемся выбрать следующий полу-период.
		// также пропускаем выборку если управление по брезенхему и предыдущий период симистор был отключен

		if (index_input - prev_index_input > MAX_INDEX_BY_PERIOD || index_input - prev_index_input < MIN_INDEX_BY_PERIOD || !br_on)
		{
			index_input = prev_index_input;
			SqNaprT = SqNaprPrevT;
		}
		else
			CntPeriod++; // Если число в выборке допустимо, то прибавляем счетчик полу-периодов выборки

		// Если считали достаточное количество полу-периодов, тогда расчет закончен.
		if (CntPeriod >= CNT_PERIOD)
		{
			if (flCorrASC712 == 0) indexOut = index_input;
			StateVolts = 2;// Если был расчет тока (напряжения), то ставим признак его окончания
			CntPeriodPause = 0;
		}
	}
	else
	{
		CntPeriodPause++;
	}

	if (StateVolts == 4)
	{
		// Если пропустили два по необходимому числу полу-периодов, запускаем расчет.
		// Еще одно условие, чтобы мы не находились в режиме ввода клавиш, тогда расчет не запускаем, чтобы не тормозить отчаянно 
		// при вводе информации
		if (CntPeriodPause > CNT_PERIOD && CountKeys == 0)
		{
			StateVolts = 0;
			if (CorrectASC712)  flCorrASC712 = !flCorrASC712; // Читаем через раз, то мощность, то напряжение если, конечно установлено что надо считать мощность.
		}
	}

	if (StateVolts == 0)
	{
		index_input = 0;
		StateVolts = 1;
		MaxVolts = 0;
		TCNT4H = 0x00;
		TCNT4L = 0x00;
		//        TCNT3H=0x00;
		//        TCNT3L=0x00;
		CntPeriod = 0;
		SqNaprT = 0;
	}

	prev_index_input = index_input;
	SqNaprPrevT = SqNaprT;
	br_on = true;

#if USE_ASC712==0
	if (UstPower >= Power)
	{
		// Если мощность больше или равна номинальной, включаем триак всегда, при этом прерывание на закрытие никогда не выполнится.  
		TimeOpenTriac = 32000;
		TimeOpenTriacFact = 32000;
		// Если НПГ инициализирован, токда подаем питание на ТЭНы, чтобы их не спалить при не заполненном НПГ
		if (StateNPG > 1) digitalWrite(PIN_TRIAC, HIGH);
	}
	else
	{
		TimeOpenTriacFact = TimeOpenTriac;
	}

	// Если мощность не установлена отключена, или состояние машины конечное, то на всякий случай отключаем
	if (UstPower <= 0 || StateMachine >= 100) digitalWrite(PIN_TRIAC, LOW);

	if (TimeOpenTriac <= 10)
	{
		// Если НПГ инициализирован, токда подаем питание на ТЭНы, чтобы их не спалить при не заполненном НПГ
		if (StateNPG > 1 && UstPower > 0) digitalWrite(PIN_TRIAC, HIGH);
		TimeOpenTriacFact = 32000;
	}

	//    TimeOpenTriacFact=TimeOpenTriac;
	//TimeOpenTriac=2000;
	// В прерывании нуля настраиваем, чтобы прерывание на 5-м таймере выдалось через то время, которое мы ранее рассчитали.
	OCR5AH = (char)(TimeOpenTriacFact >> 8);
	OCR5AL = (char)TimeOpenTriacFact;

	if (TimeOpenKLP == 0) TimeOpenKLP = 32000;
	OCR5BH = (char)(TimeOpenKLP >> 8);
	OCR5BL = (char)TimeOpenKLP;
	// Если считаем ток(напрряжение), тогда 

#else
	// Устанавливаем закрытие симистора по прерыванию таймера через некоторое время (отступить от таблицы мощности на 2 шага вполе достаточно).
	TimeOpenTriacFact=tableT[MAX_TABLE_T-2];
	TimeOpenTriac=TimeOpenTriacFact;
	OCR5AH=(char)(TimeOpenTriacFact>>8);
	OCR5AL=(char)TimeOpenTriacFact;
	// Если процент брезенхема не рассчитан, а мощность установлена, то запускаем измерительный период
	if (UstPower>0 && b_value[0]==0 || UstPower>=Power) digitalWrite(PIN_TRIAC,HIGH);
	else
		if (UstPower<=0) digitalWrite(PIN_TRIAC,LOW);  // Если мощность не установлена, то на реле подаюм нулевой сигнал
		else
		{
			br_on=bresenham_getNext(0);
			digitalWrite(PIN_TRIAC,br_on); // Иначе стандартно вызываем алгоритм брезехема.
		}
#endif


	// фазовое управление давигателем пока не используем 
	//    TimeOpenDvigatel=5000; 
	//    if (SpeedNBK>0)
	//    {
	//      TimeOpenDvigatel=TicZero/100;
	//      TimeOpenDvigatel=TimeOpenDvigatel*SpeedNBK;
	//      TimeOpenDvigatel=TicZero-TimeOpenDvigatel;
	//      if (SpeedNBK>=100) digitalWrite(PIN_DVIGATEL, HIGH);  
	//    }
	//
	//    OCR5CH=(char)(TimeOpenDvigatel>>8);
	//    OCR5CL=(char)TimeOpenDvigatel;

	// В прерывании нуля управляем открытием клапанов (а их лучше открывать по 0, чтобы не было помех)
	// Синхронизацию пока отключим
	//    if (!flSyncKLP) // Если клапана не находятся в режиме синхронизации
  {
	  for (i = 0; i<MAX_KLP; i++)
	  {
		  // Разбираемся с состоянием клапана
		  if (KlState[i] == 0)
		  {
			  flOpenClose = 0;
			  // Состояние клапана - выключен            
			  if (KlCount[i]>KlClose[i]) // Если количество тиков превышает установленное для состояния "закрыто", переводим клапан в состояние "открыто"
			  {
				  // Клапан переводим в состояние-включен
				  KlState[i] = 1;
				  KlCount[i] = 0;
				  if (KlOpen[i]) flOpenClose = 1;
			  }
		  }
		  else
		  {
			  flOpenClose = 1;
			  // Состояние клапана - выключен
			  if (KlCount[i] > KlOpen[i]) // Если количество тиков превышает установленное для состояния "открыто", переводим клапан в состояние "открыто"
			  {
				  KlState[i] = 0;
				  KlCount[i] = 0;
				  if (KlClose[i]) flOpenClose = 0;
			  }
		  }

		  // Если клапан в принципе не должен выключаться то всегда переводим в состояние влкючен
		  if (KlClose[i] == 0)
		  {
			  flOpenClose = 1;
			  KlState[i] = 1;
		  }
		  // Если клапан в принципе не должен включатся,то всегда переводим  в состояние выключаем
		  if (KlOpen[i] == 0)
		  {
			  flOpenClose = 0;
			  KlState[i] = 0;
			  KlCount[i] = 0;
		  }

		  // С состоянием клапана разобрались, тепер в зависимости от состояния включаем или выключаем его

		  if (!flOpenClose)
		  {  // Если клапан-выключен, то выключаем его в любом случае
			  digitalWrite(PIN_KLP_BEG + i, !KLP_HIGH);
		  }
		  else
		  {  // Если состояние клапана - включен, включаем его только в том случае, если клапан в находится в режиме ШИМ
			  // Или клапан находится в режиме фазового управления, но включен менее, чем полсекунды назад, или время фазового управления еще не рассчитано, то включаем его тоже,
			  // иначе для режима фазового управления клапан включится по принципу фазового управления в прерывании. Или временно фазовое управления убрано
			  if (KlReg[i] == 0 || KlCount[i] < 50 || TimeOpenKLP == 32000 || flNoPhase)
				  digitalWrite(PIN_KLP_BEG + i, KLP_HIGH);
		  }

		  KlCount[i]++;
	  }
  }

}

// Функция вызывается по прерыванию нуля от датчика потока жидкости (пока почти бесполезная функция, скорость прокачки браги насосом НБК проточный датчик считает плохо ввиду малой чувствительности
// а скорость потока жидкости считать мне не так уж и нужно.
#ifdef FLOW_DETECT_ON
void flow_crosss_int()
{
	long Mils_end;
	long razn;
	FlowCount++;
	if (FlowCount >= FLOW_DETECT_ON)
	{
		//    Serial1.print("Sec25=");
		//    Serial1.println(Sec25);
		Flow = (long)3600 * 5 / ((long)Sec5*FLOW_MLITR);
		//    Serial1.print("Flow=");
		//    Serial1.println(Flow);
		// За это время могли прокачать не литр
		Sec5 = 0;
		FlowCount = 0;
	}

}
#endif

void my_lcdprint(char *s)
{
	char i;
	char len;
	len = strlen(lcd_buffer);
	for (i = len; i < 16; i++) s[i] = ' ';
	s[16] = 0;
	lcd.print(s);
}

void DisplayData()
{
	int tic1;
	unsigned char hour, minute, second;
	static int PrevState = 0;
	static char flDspDop = 0; // Флаг для отображения информации (через раз)
	flDspDop = !flDspDop;

	hour = Seconds / 3600;
	tic1 = Seconds % 3600;
	minute = tic1 / 60;
	second = tic1 % 60;
	int V1, V2, V3;

	if (FlState == 0)
		lcd.setCursor(0, 0);
	else
	{
		// Если предыдущее состояние было 0, то даем задерку в 1/10 секунды, чтобы не слишком часто обновлялся
		// дисплей.
		if (PrevState == 0)  delay(100);

		if (FlState != PrevState)
		{
			lcd.clear();  //очистка дисплея   
			PrevState = FlState;
		}

		lcd.setCursor(0, 0);
	}

	switch (FlState)
	{
	case 0:

		if (DispPage < 2) // Первые две страницы отображаются по-разному, остальные всегда одни и те же
		{
			switch (IspReg)
			{
			case 101: // Displaying
				//sprintf(lcd_buffer,"S=%5u TT=%5u",Seconds,MaxTimeTimer); //запись в буфер текста и значений температуры в подготовленном

				//  Выводим сетевое напряжение по тому же принципу, что и работают дешевые вольтметры, то есть максимальное количество вольт в сети умножаем на 0,707
				//  это напряжение нужно для калибровки нашего измерителя

				if (DispPage == 0)
				{
					sprintf(lcd_buffer, "%02u:%02u:%02u DSP 1/2", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
					my_lcdprint(lcd_buffer);
					sprintf(lcd_buffer, "Zr=%4u U=%3i", TicZero, MaxVoltsOut); //запись в буфер текста и значений температуры в подготовленном
				}

				if (DispPage == 1)
				{
					sprintf(lcd_buffer, "D2 T=%3u,%3u,%3u", temps[0], temps[1], temps[2]); //запись в буфер текста и значений температуры в подготовленном
					my_lcdprint(lcd_buffer);
					sprintf(lcd_buffer, "V=%4u,%4u,%4u", U_VODA, U_UROVEN, U_GLV); //запись в буфер текста и значений температуры в подготовленном
				}
				lcd.setCursor(0, 1);
				my_lcdprint(lcd_buffer);

				break;
			case 102: // Термостат         
				if (DispPage == 0)
				{
					sprintf(lcd_buffer, "%02u:%02u:%02u TermSt", hour, minute, second, Delta); //запись в буфер текста и значений температуры в подготовленном
					my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
					sprintf(lcd_buffer, "t=%3i/%3i(%2i) %1i", temps[TEMP_TERMOSTAT], TempTerm, Delta, StateMachine); //запись в буфер текста и значений температуры в подготовленном
				}
				else
				{
					sprintf(lcd_buffer, "D2 T=%3u,%3u,%3u", temps[0], temps[1], temps[2]); //запись в буфер текста и значений температуры в подготовленном
					my_lcdprint(lcd_buffer);
					sprintf(lcd_buffer, "%3u,%3u P=%3imm", temps[3], temps[4], U_MPX5010); //запись в буфер текста и значений температуры в подготовленном
				}
				break;
			case 115: // Таймер
				if (DispPage == 0)
				{
					sprintf(lcd_buffer, "%02u:%02u:%02u Timer", hour, minute, second, Delta); //запись в буфер текста и значений температуры в подготовленном
					my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
					minute = Seconds / 60;
					sprintf(lcd_buffer, "tm=%3i/%3i %4iW", minute, timerMinute, UstPower); //запись в буфер текста и значений температуры в подготовленном
				}
				else
				{
					sprintf(lcd_buffer, "D2 T=%3u,%3u,%3u", temps[0], temps[1], temps[2]); //запись в буфер текста и значений температуры в подготовленном
					my_lcdprint(lcd_buffer);
					sprintf(lcd_buffer, "%3u,%3u %4iW", temps[3], temps[4], PowerMinute); //запись в буфер текста и значений температуры в подготовленном
				}
				break;
			case 116: // Пивоварня - клон браумастера
				if (DispPage == 0)
				{
					sprintf(lcd_buffer, "%02u:%02u:%02u beer", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
					my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
					if (StateMachine == 2)   sprintf(lcd_buffer, "T=%3i/%3i P%2i/%2i", temps[TEMP_TERMOSTAT], (int)tempP[KlTek] * 10, (int)KlTek + 1, (int)CntPause); //запись в буфер текста и значений температуры в подготовленном
					if (StateMachine == 3)
					{
						if (timeP[KlTek] != 0)
							sprintf(lcd_buffer, "Ts=%5i P=%2i/%2i", time2, (int)KlTek + 1, (int)CntPause); //запись в буфер текста и значений температуры в подготовленном
						else
							sprintf(lcd_buffer, "Press UP to%2i/%2i", time2, (int)KlTek + 2, (int)CntPause); //запись в буфер текста и значений температуры в подготовленном

					}
					if (StateMachine == 100)   sprintf(lcd_buffer, "end"); //запись в буфер текста и значений температуры в подготовленном
				}
				else
				{
					sprintf(lcd_buffer, "D2 T=%3u,%3u,%3u", temps[0], temps[1], temps[2]); //запись в буфер текста и значений температуры в подготовленном
					my_lcdprint(lcd_buffer);
					sprintf(lcd_buffer, "mix=%5i %4iW", time1, UstPower); //запись в буфер текста и значений температуры в подготовленном
				}
				break;
			case 103: // Регулятор мощности
				if (DispPage == 0)
				{
#ifndef USE_SLAVE
					sprintf(lcd_buffer, "%02u:%02u:%02u RMU=%3u", hour, minute, second, MaxVoltsOut); //запись в буфер текста и значений температуры в подготовленном
					my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
					sprintf(lcd_buffer, "P=%4u/%4u c%3u", UstPowerReg, Power, indexOut); //запись в буфер текста и значений температуры в подготовленном
#else
					sprintf(lcd_buffer,"%02u:%02u:%02u RMU=%3u",hour,minute,second,MaxVoltsOut); //запись в буфер текста и значений температуры в подготовленном
					my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
					sprintf(lcd_buffer,"PSlv=%4u/%4u",UstPower,Power); //запись в буфер текста и значений температуры в подготовленном
#endif
				}
				else
				{
					sprintf(lcd_buffer, "D2 T=%3u,%3u,%3u", temps[0], temps[1], temps[2]); //запись в буфер текста и значений температуры в подготовленном
					my_lcdprint(lcd_buffer);
#ifndef USE_SLAVE
					sprintf(lcd_buffer, "V=%4u,%4u,%4u", U_VODA, U_UROVEN, U_GLV); //запись в буфер текста и значений температуры в подготовленном
#else
					sprintf(lcd_buffer,"SlaveOn=%1i ",(int) SlaveON); //запись в буфер текста и значений температуры в подготовленном
#endif
				}
				break;
			case 105: // Отбор голов
				if (DispPage == 0)
				{
					switch (StateMachine)
					{
					case 0: //Не запущено
					case 1: //Нагрев до температуры 50 градусов
						sprintf(lcd_buffer, "%02u:%02u:%02u sGl Not", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tD=%3i/%3i %4iW", temps[TEMP_DEFL], TempDeflBegDistil, Power);
						break;
					case 2: //Ожидание закипания (прогреется дефлегматор)
						sprintf(lcd_buffer, "%02u:%02u:%02u sGl Rzg", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tD=%3i/%3i %4iW", temps[TEMP_DEFL], TempDeflBegDistil, Power);
						break;
					case 3: //Ожидание закипания (прогреется куб дефлегматор)
						sprintf(lcd_buffer, "%02u:%02u:%02u sGl Rzg", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tK=%3i/%3i %4iW", temps[TEMP_KUB], TempDeflBegDistil, Power);
						break;
					case 4: //Отбор голов
						sprintf(lcd_buffer, "%02u:%02u:%02u sGl Otb", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tK=%3i/%3i %4iW", temps[TEMP_KUB], Temp3P, PowerGlvDistil);
						break;
					case 5: //Ожидание 60 секунд для охлаждения
						sprintf(lcd_buffer, "%02u:%02u:%02u sOtbGlv", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tK=%3i Wait=%4i", temps[TEMP_KUB], SecondsEnd); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 100: //Окончание
						sprintf(lcd_buffer, "%02u:%02u:%02u sOtbGlv", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tK=%3i   end", temps[TEMP_KUB]); //запись в буфер текста и значений температуры в подготовленном
						break;
					}
				}
				else
				{
					sprintf(lcd_buffer, "D2 T=%3u,%3u,%3u", temps[0], temps[1], temps[2]); //запись в буфер текста и значений температуры в подготовленном
					my_lcdprint(lcd_buffer);
					sprintf(lcd_buffer, "V=%4u,%4u,%4u", U_VODA, U_UROVEN, U_GLV); //запись в буфер текста и значений температуры в подготовленном
				}

				break;
			case 104: // Перевый (недробный) отбор
			case 106: // Второй дробный отбор
			case 107: // Третий дробный отбор
				if (DispPage == 0)
				{
					if (IspReg == 104)
					{
						V1 = 1;
						V2 = Temp1P;
					}
					if (IspReg == 106)
					{
						V1 = 2;
						V2 = Temp2P;
					}
					if (IspReg == 107)
					{
						V1 = 3;
						V2 = Temp3P;
					}

					sprintf(lcd_buffer, "%02u:%02u:%02u %1u-Otbor", hour, minute, second, V1); //запись в буфер текста и значений температуры в подготовленном

					switch (StateMachine)
					{
					case 0: //Не запущено
					case 1: //Нагрев до температуры 50 градусов
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						break;
					case 2: //Ожидание закипания (прогреется дефлегматор)
						sprintf(lcd_buffer, "%02u:%02u:%02u %1u-O Rzg", hour, minute, second, V1); //запись в буфер текста и значений температуры в подготовленном
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tD=%3i/%3i %4iW", temps[TEMP_DEFL], TempDeflBegDistil, Power);
						break;
					case 3: //Дистилляция
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tK=%3i/%3i %4iW", temps[TEMP_KUB], V2, PowerDistil);
						break;
					case 4: //Ожидание 60 секунд для охлаждения
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tK=%3i Wait=%4i", temps[TEMP_KUB], SecondsEnd); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 100: //Окончание
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tK=%3i   end", temps[TEMP_KUB]); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 101: //Температура в ТСА превысила предельную
						sprintf(lcd_buffer, "%02u:%02u:%02u TSA!", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tTSA=%3i/%3i ", temps[TEMP_TSA], MAX_TEMP_TSA); //запись в буфер текста и значений температуры в подготовленном
						break;
					}
				}
				else
				{
					sprintf(lcd_buffer, "D2 T=%3u,%3u,%3u", temps[0], temps[1], temps[2]); //запись в буфер текста и значений температуры в подготовленном
					my_lcdprint(lcd_buffer);
					sprintf(lcd_buffer, "V%4u,%4u %4uW", U_VODA, U_UROVEN, PowerDistil); //запись в буфер текста и значений температуры в подготовленном
				}
				break;

			case 108: // Разваривание
			case 113: // Разваривание мучно-солодового затора (без варки).
			case 114: // Разваривание
				if (DispPage == 0)
				{
					if (IspReg == 114)  sprintf(lcd_buffer, "%02u:%02u:%02u HLD Ztr", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
					else sprintf(lcd_buffer, "%02u:%02u:%02u Razvar", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
					my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD

					switch (StateMachine)
					{
					case 0: //Не запущено
					case 1: //Нагрев до температуры 50 градусов
						sprintf(lcd_buffer, "t=%3i P=%4i", temps[TEMP_RAZVAR], UstPower); //запись в буфер текста и значений температуры в подготовленном
						break;
						//            case 1: //Нагрев до температуры 50 градусов
						//              sprintf(lcd_buffer,"t=%3i/500 %4iW",temps[TEMP_RAZVAR],UstPower); //запись в буфер текста и значений температуры в подготовленном
						//              break;
					case 2: //Поддержание температуры 50 градусов, пока не произойдет ручной переход к следующему этапу.
						sprintf(lcd_buffer, "t=%3i Press Up", temps[TEMP_RAZVAR]); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 3: //Нагрев до температуры 64 градуса
						sprintf(lcd_buffer, "t=%3i/%3i %4iW", temps[TEMP_RAZVAR], TempZasypSolod, PowerVarkaZerno); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 4: //Ожидание 15 минут, поддержка температуры
						sprintf(lcd_buffer, "t=%3i %4iW %4i", temps[TEMP_RAZVAR], UstPower, time2); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 5: //Нагрев до кипения
						if (ds1820_devices < 2)
							sprintf(lcd_buffer, "tK=%3i/%3i %4iW", temps[TEMP_RAZVAR], TempKipenZator, UstPower); //запись в буфер текста и значений температуры в подготовленном
						else
							sprintf(lcd_buffer, "tD=%3i/%3i %4iW", temps[TEMP_DEFL], TempKipenZator, UstPower); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 6: //Варка
						sprintf(lcd_buffer, "t=%3i %4iW %4i", temps[TEMP_RAZVAR], PowerRazvZerno, time2); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 7: //Охлаждение до температыры осахаривания
						sprintf(lcd_buffer, "tK=%3i/%3i HLD-1", temps[TEMP_RAZVAR], TempZasypSolod); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 8: //Поддержание температуры 50 градусов, пока не произойдет ручной переход к следующему этапу.
						sprintf(lcd_buffer, "t=%3i SOLOD & Up", temps[TEMP_RAZVAR]); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 9: //Мешаем 10 минут
						sprintf(lcd_buffer, "tK=%3i MIX %4i", temps[TEMP_RAZVAR], time2); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 10: //Осахаривание
						sprintf(lcd_buffer, "tK=%3i OSH %4i", temps[TEMP_RAZVAR], time2); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 11: //Охлаждение до температыры осахаривания
						sprintf(lcd_buffer, "tK=%3i/400 HLD-2", temps[TEMP_RAZVAR]); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 12: //Охлаждение до температыры осахаривания
						sprintf(lcd_buffer, "tK=%3i/%3i HLD-3", temps[TEMP_RAZVAR], TempHLDZatorBrog); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 13: //Поддержка брожения, ничего не делаем, только мешаем периодически
						sprintf(lcd_buffer, "tK=%3i/360 BROG", temps[TEMP_RAZVAR]); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 14: //Поддержка брожения - охлаждение
						sprintf(lcd_buffer, "tK=%3i/355 BROG", temps[TEMP_RAZVAR]); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 100: //Окончание
						sprintf(lcd_buffer, "t=%3i end       ", temps[TEMP_RAZVAR]); //запись в буфер текста и значений температуры в подготовленном
						break;
					}
				}
				else
				{
					sprintf(lcd_buffer, "D2 T=%3u,%3u,%3u", temps[0], temps[1], temps[2]); //запись в буфер текста и значений температуры в подготовленном
					my_lcdprint(lcd_buffer);
					sprintf(lcd_buffer, "V=%4ug%4un%4u", U_VODA, U_GAS, U_NPG); //запись в буфер текста и значений температуры в подготовленном
				}
				break;
			case 109: // Ректификация
				if (DispPage == 0)
				{
					switch (StateMachine)
					{
					case 0: //Не запущено
						sprintf(lcd_buffer, "%02u:%02u:%02u Rect", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						//sprintf(lcd_buffer,"tK=%3i P=%4i",temps[TEMP_KUB],Power); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 2: //Разгон
						sprintf(lcd_buffer, "%02u:%02u:%02u R RZG", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tK=%3i/%3i %4iW", temps[TEMP_KUB], tEndRectRazgon, UstPower); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 3: //Стабилицация колонны
						sprintf(lcd_buffer, "%02u:%02u:%02u R NSB", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tN=%3i(%3i)%4iW", temps[TEMP_RK20], (int)(Seconds - SecTempPrev), PowerRect); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 4: //Отбор голов
						sprintf(lcd_buffer, "%02u:%02u:%02u R GLV", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    

						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						if (UrovenProvodimostSR == 0)
							sprintf(lcd_buffer, "tK=%3i/%3i %4iW", temps[TEMP_KUB], tEndRectOtbGlv, PowerRect); //запись в буфер текста и значений температуры в подготовленном
						else
							if (UrovenProvodimostSR > 0)
							{
								if (UrovenProvodimostSR == 2) sprintf(lcd_buffer, "Pr=%3i/%3i %4iW", U_GLV, UROVEN_ALARM, PowerRect); //запись в буфер текста и значений температуры в подготовленном
								else sprintf(lcd_buffer, "Pr=%3i/%3i %4iW", U_GLV, UrovenProvodimostSR, PowerRect); //запись в буфер текста и значений температуры в подготовленном
							}
							else
								sprintf(lcd_buffer, "Tm=%3i/%3i %4iW", (int)SecOstatok, -UrovenProvodimostSR, PowerRect); //запись в буфер текста и значений температуры в подготовленном
						break;

					case 5: //Стоп, ожидание возврата температуры
						sprintf(lcd_buffer, "%02u:%02u:%02u R Stop ", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tN=%3i/%3i %2i%%", temps[TEMP_RK20], tStabSR, ProcChimSR); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 6: //Ректификация
						sprintf(lcd_buffer, "%02u:%02u:%02u RSt %2i%%", hour, minute, second, ProcChimSR); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tN=%3i/%3i/d%2i ", temps[TEMP_RK20], tStabSR + tDeltaRect, tDeltaRect); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 7: //Отбор хвостов
						sprintf(lcd_buffer, "%02u:%02u:%02u R Hvost", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tK=%3i/%3i    ", temps[TEMP_KUB], tEndRect); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 8: //Отбор ожидание 3 минут
						sprintf(lcd_buffer, "%02u:%02u:%02u R Wait ", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tK=%3i/%3i ", temps[TEMP_KUB], tEndRect); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 9: //Ожидание датчика уровня
						sprintf(lcd_buffer, "%02u:%02u:%02u R Wait ", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "by Urov=%3i/%3i ", U_UROVEN, UROVEN_ALARM); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 100: //Окончание
						sprintf(lcd_buffer, "%02u:%02u:%02u Rec End", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tK=%3i/%3i ", temps[TEMP_KUB], tEndRect); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 101: //Температура в ТСА превысила предельную
						sprintf(lcd_buffer, "%02u:%02u:%02u TSA!", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод сz`одержимого буфера на LCD
						sprintf(lcd_buffer, "tT=%3i/%3i ", temps[TEMP_TSA], MAX_TEMP_TSA); //запись в буфер текста и значений температуры в подготовленном
						break;

					}
				}
				else
				{
					sprintf(lcd_buffer, "D2 T=%3u,%3u,%3u", temps[0], temps[1], temps[2]); //запись в буфер текста и значений температуры в подготовленном
					my_lcdprint(lcd_buffer);
					if (StateMachine != 5) sprintf(lcd_buffer, "%3immV=%4u,%4u", U_MPX5010, U_UROVEN, U_GLV); //запись в буфер текста и значений температуры в подготовленном
					else sprintf(lcd_buffer, "%3imm reSt=%5i", U_MPX5010, time1); //запись в буфер текста и значений температуры в подготовленном
				}
				break;
			case 110: // Дистилляция с дефлегматором
				if (DispPage == 0)
				{
					switch (StateMachine)
					{
					case 0: //Не запущено
					case 1: //Нагрев до температуры 50 градусов
						sprintf(lcd_buffer, "%02u:%02u:%02u DD", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tD=%3i/%3i %4iW", temps[TEMP_DEFL], TempDeflBegDistil, Power);
						break;
					case 2: //Ожидание закипания (прогреется дефлегматор)
						sprintf(lcd_buffer, "%02u:%02u:%02u DD Rzg", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tD=%3i/%3i %4iW", temps[TEMP_DEFL], TempDeflBegDistil, UstPower);
						break;
					case 3: //Ожидание закипания (прогреется куб дефлегматор)
						sprintf(lcd_buffer, "%02u:%02u:%02u DD Rzg", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tK=%3i/%3i %4iW", temps[TEMP_KUB], TempDeflBegDistil, UstPower);
						break;
					case 4: //Работа без дефлегматора
						sprintf(lcd_buffer, "%02u:%02u:%02u DD BezD", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tD=%3i/%3i %4iW", temps[TEMP_DEFL], TempDefl, UstPower);
						break;
					case 5: //Работа с 50% дефлегмацией
						sprintf(lcd_buffer, "%02u:%02u:%02u DD 50%%", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tD=%3i/%3i %4iW", temps[TEMP_DEFL], TempDefl - DeltaDefl, UstPower);
						break;
					case 6: //Работа с 100% дефлегмацией
						sprintf(lcd_buffer, "%02u:%02u:%02u DD 100%%", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tD=%3i/%3i %4iW", temps[TEMP_DEFL], TempDefl - DeltaDefl, UstPower);
						break;
					case 7: //Ожидание для охлаждения
						sprintf(lcd_buffer, "%02u:%02u:%02u DD Wait", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tK=%3i Wait=%4i", temps[TEMP_KUB], SecondsEnd); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 100: //Окончание
						sprintf(lcd_buffer, "%02u:%02u:%02u DD end", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tK=%3i   end", temps[TEMP_KUB]); //запись в буфер текста и значений температуры в подготовленном
						break;
					}
				}
				else
				{
					sprintf(lcd_buffer, "D2 T=%3u,%3u,%3u", temps[0], temps[1], temps[2]); //запись в буфер текста и значений температуры в подготовленном
					my_lcdprint(lcd_buffer);
					sprintf(lcd_buffer, "V%4u,%4u-%4iW", U_VODA, U_UROVEN, deltaPower); //запись в буфер текста и значений температуры в подготовленном
				}
				break;
			case 111: // НДРФ
				if (DispPage == 0)
				{
					switch (StateMachine)
					{
					case 0: //Не запущено
						sprintf(lcd_buffer, "%02u:%02u:%02u NDRF", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tK=%3i P=%4i", temps[TEMP_KUB], Power); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 2: //Разгон
						sprintf(lcd_buffer, "%02u:%02u:%02u ND RZG", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tK=%3i/%3i %4iW", temps[TEMP_KUB], tEndRectRazgon, UstPower); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 3: //Стабилицация колонны
						sprintf(lcd_buffer, "%02u:%02u:%02u ND NSB", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "t=%3i(%4i)%4iW", temps[TEMP_RK20], (int)(SecOstatok), PowerRect); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 4: //Отбор голов
						sprintf(lcd_buffer, "%02u:%02u:%02u ND GLV", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						if (UrovenProvodimostSR == 0)
							sprintf(lcd_buffer, "tK=%3i/%3i %4iW", temps[TEMP_KUB], tEndRectOtbGlv, PowerRect); //запись в буфер текста и значений температуры в подготовленном
						else
							if (UrovenProvodimostSR > 0)
								sprintf(lcd_buffer, "Pr=%3i/%3i %4iW", U_GLV, UrovenProvodimostSR, PowerRect); //запись в буфер текста и значений температуры в подготовленном
							else
								sprintf(lcd_buffer, "Tm=%3i/%3i %4iW", (int)SecOstatok, -UrovenProvodimostSR, PowerRect); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 5: //Стоп, ожидание возврата температуры
						sprintf(lcd_buffer, "%02u:%02u:%02u ND Stop", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tN=%3i/%3i %2i%%", temps[TEMP_RK20], tStabSR, ProcChimSR); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 6: //Ректификация
						sprintf(lcd_buffer, "%02u:%02u:%02u NDst %2i%%", hour, minute, second, ProcChimSR); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tN=%3i/%3i/d%2i ", temps[TEMP_RK20], tStabSR + tDeltaRect, tDeltaRect); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 7: //Отбор хвостов
						sprintf(lcd_buffer, "%02u:%02u:%02u ND Hvst", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tK=%3i/%3i    ", temps[TEMP_KUB], tEndRect); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 8: //Отбор ожидание 3 минут
						sprintf(lcd_buffer, "%02u:%02u:%02u ND Wait", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tK=%3i/%3i ", temps[TEMP_KUB], tEndRect); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 9: //Ожидание датчика уровня
						sprintf(lcd_buffer, "%02u:%02u:%02u R Wait ", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "by Urov=%3i/%3i ", U_UROVEN, UROVEN_ALARM); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 100: //Окончание
						sprintf(lcd_buffer, "%02u:%02u:%02u ND End", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tK=%3i/%3i ", temps[TEMP_KUB], tEndRect); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 101: //Температура в ТСА превысила предельную
						sprintf(lcd_buffer, "%02u:%02u:%02u TSA!", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод сz`одержимого буфера на LCD
						sprintf(lcd_buffer, "tT=%3i/%3i ", temps[TEMP_TSA], MAX_TEMP_TSA); //запись в буфер текста и значений температуры в подготовленном
						break;

					}
				}
				else
				{
					sprintf(lcd_buffer, "D2 T=%3u,%3u,%3u", temps[0], temps[1], temps[2]); //запись в буфер текста и значений температуры в подготовленном
					my_lcdprint(lcd_buffer);
					sprintf(lcd_buffer, "%3immV=%4u,%4u", U_MPX5010, U_UROVEN, U_GLV); //запись в буфер текста и значений температуры в подготовленном
				}
				break;
			case 112: // NBK
				if (DispPage == 0)
				{
					switch (StateMachine)
					{
					case 0: //Не запущено
						sprintf(lcd_buffer, "%02u:%02u:%02u NBK", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tK=%3i,%3imm", temps[TEMP_KUB], U_MPX5010); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 1: //Ожидание закипания (прогреется дефлегматор)
					case 2: //Ожидание закипания (прогреется дефлегматор)
						sprintf(lcd_buffer, "%02u:%02u:%02u NBK Rzg", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tD=%3i/%3i %4iW", temps[TEMP_DEFL], TempDeflBegDistil, UstPower);
						break;
					case 3: //Ожидание запуска
						sprintf(lcd_buffer, "%02u:%02u:%02u NBK Beg", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "UP to Beg %3imm", U_MPX5010); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 4: //Запущено
						sprintf(lcd_buffer, "%02u:%02u:%02u NBK Wrk", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "Sp=%4i,%3imm", (int)SpeedNBK, U_MPX5010); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 5: //Превышение температуры вверху
						sprintf(lcd_buffer, "%02u:%02u:%02u NBK tmp", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "tD=%3i/970,s%4i", temps[TEMP_DEFL], time2); //запись в буфер текста и значений температуры в подготовленном
						break;
					case 100: //Окончание
						sprintf(lcd_buffer, "%02u:%02u:%02u NBK End", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
						//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
						my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
						sprintf(lcd_buffer, "Sp=%4i,%3imm", (int)SpeedNBK, U_MPX5010); //запись в буфер текста и значений температуры в подготовленном
						break;
					}
				}
				else
				{
					sprintf(lcd_buffer, "D2 T=%3u,%3u,%3u", temps[0], temps[1], temps[2]); //запись в буфер текста и значений температуры в подготовленном
					my_lcdprint(lcd_buffer);
					sprintf(lcd_buffer, "%4uW, %3imm", UstPower, U_MPX5010); //запись в буфер текста и значений температуры в подготовленном
				}
				break;

			case 130: // Резерв
				sprintf(lcd_buffer, "%02u:%02u:%02u Reserv", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
				//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
				my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
				sprintf(lcd_buffer, "KLP %3i %3i /%1i", KlOpen[KlTek], KlClose[KlTek], KlTek); //запись в буфер текста и значений температуры в подготовленном
				break;
			case 129: // тест клапанов
				if (DispPage == 0)
				{
					sprintf(lcd_buffer, "%02u:%02u:%02u tst KLP", hour, minute, second); //запись в буфер текста и значений температуры в подготовленном
					//sprintf(lcd_buffer,"%u%u%u%u  %u%u%u%u",PINB.4,PINB.3,PINB.2,PINA.7, PINA.6,PINA.5,PINA.4,PINA.3); //запись в буфер текста и значений температуры в подготовленном                    
					my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
					sprintf(lcd_buffer, "St=%3i CHIM=%3i", StateMachine, ProcChimSR); //запись в буфер текста и значений температуры в подготовленном
				}
				else
				{
					sprintf(lcd_buffer, "D2 T=%3u,%3u,%3u", temps[0], temps[1], temps[2]); //запись в буфер текста и значений температуры в подготовленном
					my_lcdprint(lcd_buffer);
					sprintf(lcd_buffer, "%3u,%3u Gas=%4u", temps[3], temps[4], U_GAS); //запись в буфер текста и значений температуры в подготовленном
				}
				break;
			case 248:
				sprintf(lcd_buffer, "LOW LEVEL VOLTS!"); //запись в буфер текста и значений температуры в подготовленном
				my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
				sprintf(lcd_buffer, "Umax=%i Sec=%3i", MaxVoltsOut, (int)ErrCountIndex * 12); //запись в буфер текста и значений температуры в подготовленном
				break;
			case 249:
				sprintf(lcd_buffer, "NO DETECT ZERO!"); //запись в буфер текста и значений температуры в подготовленном
				my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
				sprintf(lcd_buffer, "Umax=%i", MaxVolts); //запись в буфер текста и значений температуры в подготовленном
				break;
			case 250:
				sprintf(lcd_buffer, "ALARM VODA !"); //запись в буфер текста и значений температуры в подготовленном
				my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
				break;
			case 251:
				sprintf(lcd_buffer, "ERR Ds18b20!"); //запись в буфер текста и значений температуры в подготовленном
				my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
				sprintf(lcd_buffer, "Num=%i", NumErrDs18); //запись в буфер текста и значений температуры в подготовленном

				break;
			case 252:
				sprintf(lcd_buffer, "ALARM GAS SENS!"); //запись в буфер текста и значений температуры в подготовленном
				my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
				break;
			case 253:
				sprintf(lcd_buffer, "NPG OSUHENIE!"); //запись в буфер текста и значений температуры в подготовленном
				my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
				sprintf(lcd_buffer, "U_NPG=%i CNT=%i", U_NPG, countAlrmNPG); //запись в буфер текста и значений температуры в подготовленном
				break;
			case 254:
				sprintf(lcd_buffer, "NPG PEREPOLN!"); //запись в буфер текста и значений температуры в подготовленном
				my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
				sprintf(lcd_buffer, "U_NPG=%i CNT=%i", U_NPG, countAlrmNPG); //запись в буфер текста и значений температуры в подготовленном
				break;

			}
			// Это обычное состояние
			//
			if (StateNPG == 1 && DispPage == 0) sprintf(lcd_buffer, "Napolnenie NPG.."); //запись в буфер текста и значений температуры в подготовленном
			if (flDspDop && DispDopInfo > 0) // Если отображаем дополнительную информацию, тогда проверяем ее статус
			{
				if (DispDopInfo == 1) sprintf(lcd_buffer, "Smena TARA (%3i)", COUNT_ALARM_UROVEN - CountAlarmUroven); //Выводим на экран инфомацию о необходимости замены тары.
				if (DispDopInfo == 2) sprintf(lcd_buffer, "VODA (%3i)", COUNT_ALARM_VODA - CountAlarmVoda); //Выводим на экран инфомацию о необходимости замены тары.
				if (DispDopInfo == 3) sprintf(lcd_buffer, "Low Power %3iV", MaxVoltsOut); //Выводим на экран инфомацию о необходимости замены тары.
			}

		}
		// Третья страница отображения универсальна, там показываем напряжение, дистанцию и возможное число ошибок
		// расчета среднеквадратичного. 

		if (DispPage == 2)
		{
			sprintf(lcd_buffer, "D3 %4iW,%3uV", FactPower, MaxVoltsOut); //запись в буфер текста и значений температуры в подготовленном
			my_lcdprint(lcd_buffer);
			sprintf(lcd_buffer, "Lh=%3i,c%3u,er%2i", (int)FlowCount, indexOut, (int)ErrCountIndex); //запись в буфер текста и значений температуры в подготовленном
		}
		// На четвертой странице показываем всю температуру и давление
		if (DispPage == 3)
		{
			sprintf(lcd_buffer, "D4 T=%3u,%3u,%3u", temps[0], temps[1], temps[2]); //запись в буфер текста и значений температуры в подготовленном
			my_lcdprint(lcd_buffer);
			sprintf(lcd_buffer, "%3u,%3u P=%3imm", temps[3], temps[4], U_MPX5010); //запись в буфер текста и значений температуры в подготовленном
		}

		// На пятой странице показываем состояние датчиков уровней
		if (DispPage == 4)
		{
			sprintf(lcd_buffer, "D5 VODA=%4u", U_VODA); //запись в буфер текста и значений температуры в подготовленном
			my_lcdprint(lcd_buffer);
			sprintf(lcd_buffer, "URV=%4u GL=%4u", U_UROVEN, U_GLV); //запись в буфер текста и значений температуры в подготовленном
		}

		// На шестой странице показываем состояние датчиков уровней
		if (DispPage == 5)
		{
			sprintf(lcd_buffer, "D6 GAS=%4u", U_GAS); //запись в буфер текста и значений температуры в подготовленном
			my_lcdprint(lcd_buffer);
			sprintf(lcd_buffer, "zPS=%3u,%4uW", (int)zPSOut, UstPower); //запись в буфер текста и значений температуры в подготовленном
		}

		// На седьмой странице показываем состояние регулятора мощности
		if (DispPage == 6)
		{
			sprintf(lcd_buffer, "D7 T=%4u,Z=%4u", TimeOpenTriac, TicZero); //запись в буфер текста и значений температуры в подготовленном
			my_lcdprint(lcd_buffer);
			sprintf(lcd_buffer, "KLP=%4u,Bz=%3u", TimeOpenKLP, (int)b_value[0]); //запись в буфер текста и значений температуры в подготовленном
		}

		// На восьмой можно сменить состояние процесса.
		if (DispPage == 7)
		{
			sprintf(lcd_buffer, "D8 State Debug"); //запись в буфер текста и значений температуры в подготовленном
			my_lcdprint(lcd_buffer);
			sprintf(lcd_buffer, "StateMacine=%i", (int)StateMachine); //запись в буфер текста и значений температуры в подготовленном
		}

		// На девятой состояние ПИД-регулятора
		if (DispPage == 8)
		{
			sprintf(lcd_buffer, "D9 N=%4i O=%4i", NewErr, OldErrOut); //запись в буфер текста и значений температуры в подготовленном
			my_lcdprint(lcd_buffer);
			sprintf(lcd_buffer, "Dt=%4i It=%4i", Dt, It); //запись в буфер текста и значений температуры в подготовленном
		}
		// На Десятой странице показываем максимальные температуры за процесс температуру и давление
		if (DispPage == 9)
		{
			sprintf(lcd_buffer, "D10 MaxT=%3u,%3u", Maxtemps[0], Maxtemps[1]); //запись в буфер текста и значений температуры в подготовленном
			my_lcdprint(lcd_buffer);
			sprintf(lcd_buffer, "%3u,%3u,%3u", Maxtemps[2], Maxtemps[3], Maxtemps[4]); //запись в буфер текста и значений температуры в подготовленном
		}

		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 100:
		sprintf(lcd_buffer, "UstParam", FlState); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 101:
		sprintf(lcd_buffer, "IsR = Displaying"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 102:
		sprintf(lcd_buffer, "IsR = Termostat"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 103:
		sprintf(lcd_buffer, "IsR = Reg Power"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 104:
		sprintf(lcd_buffer, "IsR = 1 ND otbor"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 105:
		sprintf(lcd_buffer, "IsR = otbor GLV"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 106:
		sprintf(lcd_buffer, "IsR = 2 DR otbor"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 107:
		sprintf(lcd_buffer, "IsR = 3 DR otbor"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 108:
		sprintf(lcd_buffer, "IsR = Razvar"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Zerno", PowerRect); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 109:
		sprintf(lcd_buffer, "IsR = Rectif"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 110:// Дистилляция с дефлегматором
		sprintf(lcd_buffer, "IsR = Dist Defl"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 111:// НДРФ
		sprintf(lcd_buffer, "IsR = NDRF"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 112:// НБК
		sprintf(lcd_buffer, "IsR = NBK"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 113:// солодо-мучной затор (без варки
		sprintf(lcd_buffer, "IsR = Zator"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Solod - Muka", PowerRect); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 114:// Охлаждение затора
		sprintf(lcd_buffer, "IsR = HLD Zator"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "by Chiller&Mixer", PowerRect); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 115:// Таймер
		sprintf(lcd_buffer, "IsR = Timer"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "ust Power"); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 116:// Таймер
		sprintf(lcd_buffer, "IsR = Beer by"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "clone Braumaster"); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 130:
		sprintf(lcd_buffer, "IsR = Reserv"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "(%i)", FlState); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 129:
		sprintf(lcd_buffer, "IsR = Test KLP"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "(%i)", FlState); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 200:
		sprintf(lcd_buffer, "Max_t_Tst=%5i", TempTerm); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 201:
		sprintf(lcd_buffer, "Power TEN=%5u", Power); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 202:
		sprintf(lcd_buffer, "Power Reg=%5u", UstPowerReg); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 203:
		sprintf(lcd_buffer, "ParamUSART=%u", FlToUSART); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 204:
		sprintf(lcd_buffer, "ParamGSM=%u", FlToGSM); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 205:
		sprintf(lcd_buffer, "dtTermostat=%3i", Delta); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 206:
		sprintf(lcd_buffer, "Temp 1 Nedrobn"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Distill=%3i   ", Temp1P); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 207:
		sprintf(lcd_buffer, "Temp 2 Drobn"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Distill=%3i", Temp2P); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 208:
		sprintf(lcd_buffer, "Temp 3 Drobn"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Distill=%3i", Temp3P); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 209:
		sprintf(lcd_buffer, "Temp Okon Razgon"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Rectif=%3i", tEndRectRazgon); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 210:
		sprintf(lcd_buffer, "Power"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Rectif=%3i", PowerRect); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 211:
		sprintf(lcd_buffer, "Vvod Popravok"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "ds18b20 "); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 212:
		sprintf(lcd_buffer, "Temp Okon Otbor"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Glv Rectif=%3i", tEndRectOtbGlv); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 213:
		sprintf(lcd_buffer, "CHIM Otbor GLV"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Rectif=%5i", timeChimRectOtbGlv); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 214:
		sprintf(lcd_buffer, "%% CHIM Otbor GLV"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Rectif=%3i", ProcChimOtbGlv); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 215:
		sprintf(lcd_buffer, "CHIM Otbor SR"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Rectif=%5i", timeChimRectOtbSR); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 216:
		sprintf(lcd_buffer, "Delta Otbor SR"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Rectif=%3u", tDeltaRect); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 217:
		sprintf(lcd_buffer, "Temp Okon Otbor"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "SR Rectif=%3i", tEndRectOtbSR); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 218:
		sprintf(lcd_buffer, "Temp Okon"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Rectif=%3i", tEndRect); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 250:
		sprintf(lcd_buffer, "min %% CHIM"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, " Otbor SR=%2i", minProcChimOtbSR); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 251:
		sprintf(lcd_buffer, "Edit Temp Stab"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Rectif=%3i", tStabSR); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 252:
		sprintf(lcd_buffer, "Beg %% CHIM"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, " Otbor SR=%2i", begProcChimOtbSR); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 253:
		sprintf(lcd_buffer, "Popr MPX=%4i", P_MPX5010); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "%4i/%4i", U_MPX5010, U_MPX5010 + P_MPX5010); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 219:
		sprintf(lcd_buffer, "Power GLV simple"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Distill=%4i", PowerGlvDistil); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 220:
		sprintf(lcd_buffer, "Power simple"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Distill=%4i", PowerDistil); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 221:
		sprintf(lcd_buffer, "Temp Defl Begin"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Distill=%3i", TempDeflBegDistil); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 222:
		sprintf(lcd_buffer, "Temp Distill"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "With Defl=%3i", TempDefl); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 223:
		sprintf(lcd_buffer, "Delta Distill"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "With Defl=%3i", DeltaDefl); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 224:
		sprintf(lcd_buffer, "Temp Kub Okon"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "DistWithDefl=%3i", tEndDistDefl); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 225:
		sprintf(lcd_buffer, "BeepEndProc=%1u", BeepEndProcess); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 226:
		sprintf(lcd_buffer, "BeepStateProc=%1u", BeepStateProcess); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 227:
		sprintf(lcd_buffer, "BeepKeyPress=%1u", BeepKeyPress); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 228:
		sprintf(lcd_buffer, "Power Razvar"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Zerno=%4i", PowerRazvZerno); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 229:
		sprintf(lcd_buffer, "Power Varka"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Zerno=%4i", PowerVarkaZerno); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 230:
		sprintf(lcd_buffer, "Led Light=%3u", (unsigned int)LedLight); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer);
		break;
	case 231:
		sprintf(lcd_buffer, "U Peregrev=%3uV", (unsigned int)NaprPeregrev); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer);
		break;
	case 232:
		sprintf(lcd_buffer, "Urv Barda=%4i", UrovenBarda); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer);
		break;
	case 233:
		sprintf(lcd_buffer, "Provod SR=%4i", UrovenProvodimostSR); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer);
		break;
	case 234:
		sprintf(lcd_buffer, "Time Stab (+/-)"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Kolonna=%5isec", TimeStabKolonna); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 235:
		sprintf(lcd_buffer, "Edit T & CHIM"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Count CHIM=%3i", (int)CntCHIM); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 236:
		sprintf(lcd_buffer, "Auto - CHIM=%3i", (int)DecrementCHIM); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer);
		break;
	case 237:
		sprintf(lcd_buffer, "Auto + CHIM=%3i", (int)IncrementCHIM); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer);
		break;
	case 238:
		sprintf(lcd_buffer, "Time Auto +"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "CHIM=%5isec", TimeAutoIncCHIM); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 239:
		sprintf(lcd_buffer, "Time reStab"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Kolonna=%5isec", TimeRestabKolonna); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 240:
		sprintf(lcd_buffer, "Beer Pause"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Count =%3i", (int)CntPause); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 241:
		sprintf(lcd_buffer, "Power correct"); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "ASC712 =%3i", (int)CorrectASC712); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;

	case 300:
		sprintf(lcd_buffer, "Temp%1i=%3u", nPopr, temps[nPopr]); //запись в буфер текста и значений температуры в подготовленном
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "Popr=%3i T=%3u", ds1820_popr[nPopr], (temps[nPopr] + ds1820_popr[nPopr])); //запись в буфер текста и значений температуры в подготовленном
		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 301:
		sprintf(lcd_buffer, "TempK(%1i)=%4i", (int)nPopr, tempK[nPopr]); //запись в буфер текста и значений температуры в подготовленном
		if (flPopr == 0)
		{
			sprintf(lcd_buffer, "%s %c", lcd_buffer, '*');
		}

		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "CHIM(%1i)=%3i", (int)nPopr, (int)CHIM[nPopr]); //запись в буфер текста и значений температуры в подготовленном
		if (flPopr == 1)
		{
			sprintf(lcd_buffer, "%s %c", lcd_buffer, '*');
		}

		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;
	case 302:
		sprintf(lcd_buffer, "TempP(%1i)=%3i.0", (int)nPopr + 1, (int)tempP[nPopr]); //запись в буфер текста и значений температуры в подготовленном
		if (flPopr == 0)
		{
			sprintf(lcd_buffer, "%s %c", lcd_buffer, '*');
		}

		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		sprintf(lcd_buffer, "TimeP(%1i)=%3i m", (int)nPopr + 1, (int)timeP[nPopr]); //запись в буфер текста и значений температуры в подготовленном
		if (flPopr == 1)
		{
			sprintf(lcd_buffer, "%s %c", lcd_buffer, '*');
		}

		lcd.setCursor(0, 1);
		my_lcdprint(lcd_buffer); //вывод содержимого буфера на LCD
		break;

	default:
		break;
	}

	//    
	//  lcd.setCursor(0, 0);
	//  my_lcdprint(Seconds);
	//  lcd.setCursor(5, 0);
	//  my_lcdprint(MaxVoltsOut);
	//  lcd.setCursor(9, 0);
	//  my_lcdprint((long)MaxVoltsOut*707/1000);
	//  lcd.setCursor(0, 1);
	//  my_lcdprint(index_input);
	//  lcd.setCursor(5, 1);
	//  my_lcdprint(TimeOpenTriac);
	//  NeedDisplaying=false;
	//  lcd.setCursor(10, 1);
	//  my_lcdprint(TicZero);

	NeedDisplaying = false;

}

void writeEEPROM()
{
	int i;
	ee_addr = 0;
	eeWriteChar(PR_REWRITE_EEPROM);
	eeWriteChar(IspReg);
	eeWriteInt(Power);
	eeWriteInt(UstPowerReg);
	eeWriteInt(TempTerm);
	eeWriteInt(Delta);
	eeWriteChar(FlToUSART);
	eeWriteChar(FlToGSM);
	eeWriteInt(Temp1P);
	eeWriteInt(Temp2P);
	eeWriteInt(Temp3P);
	for (i = 0; i < MAX_DS1820; i++)
		eeWriteChar(ds1820_popr[i]);

	eeWriteInt(tEndRectRazgon);
	eeWriteInt(PowerRect);

	eeWriteInt(tEndRectOtbGlv);
	eeWriteInt(timeChimRectOtbGlv);
	eeWriteChar(ProcChimOtbGlv);
	eeWriteInt(timeChimRectOtbSR);
	eeWriteChar(tDeltaRect);
	eeWriteInt(tEndRectOtbSR);
	eeWriteInt(tEndRect);
	eeWriteInt(PowerGlvDistil);
	eeWriteInt(PowerDistil);

	eeWriteInt(TempDeflBegDistil);
	eeWriteInt(TempDefl);
	eeWriteChar(DeltaDefl);

	eeWriteChar(BeepEndProcess);
	eeWriteChar(BeepStateProcess);
	eeWriteChar(BeepKeyPress);

	eeWriteInt(PowerRazvZerno);

	eeWriteInt(tEndDistDefl);
	eeWriteChar(minProcChimOtbSR);
	eeWriteInt(PowerVarkaZerno);
	eeWriteInt(TempKipenZator);
	eeWriteInt(TempZasypSolod);
	eeWriteInt(PowerNBK);
	eeWriteChar(SpeedNBKDst);
	eeWriteInt(PowerMinute);
	eeWriteChar(begProcChimOtbSR);
	eeWriteInt(P_MPX5010);
	eeWriteChar(LedLight);
	eeWriteInt(NaprPeregrev);
	eeWriteInt(UrovenBarda);
	eeWriteInt(UrovenProvodimostSR);
	eeWriteInt(TimeStabKolonna);
	eeWriteChar(DecrementCHIM);
	eeWriteChar(IncrementCHIM);
	eeWriteInt(TimeAutoIncCHIM);
	eeWriteChar(CntCHIM);
	for (i = 0; i < COUNT_CHIM; i++)
	{
		eeWriteInt(tempK[i]);
		eeWriteChar(CHIM[i]);
	}
	eeWriteInt(TimeRestabKolonna);
	eeWriteChar(CntPause);
	for (i = 0; i < MAX_CNT_PAUSE; i++)
	{
		eeWriteChar(tempP[i]);
		eeWriteChar(timeP[i]);
	}
	eeWriteChar(CorrectASC712);

}

void readEEPROM()
{
	int i;
	ee_addr = 0;
	eeReadChar();
	IspReg = eeReadChar();
	Power = eeReadInt();
	UstPowerReg = eeReadInt();
	TempTerm = eeReadInt();
	Delta = eeReadInt();
	FlToUSART = eeReadChar();
	FlToGSM = eeReadChar();
	Temp1P = eeReadInt();
	Temp2P = eeReadInt();
	Temp3P = eeReadInt();
	for (i = 0; i < MAX_DS1820; i++)
		ds1820_popr[i] = eeReadChar();
	tEndRectRazgon = eeReadInt();
	PowerRect = eeReadInt();

	tEndRectOtbGlv = eeReadInt();
	timeChimRectOtbGlv = eeReadInt();
	ProcChimOtbGlv = eeReadChar();
	timeChimRectOtbSR = eeReadInt();
	tDeltaRect = eeReadChar();
	tEndRectOtbSR = eeReadInt();
	tEndRect = eeReadInt();
	PowerGlvDistil = eeReadInt();
	PowerDistil = eeReadInt();

	TempDeflBegDistil = eeReadInt();
	TempDefl = eeReadInt();
	DeltaDefl = eeReadChar();

	BeepEndProcess = eeReadChar();
	BeepStateProcess = eeReadChar();
	BeepKeyPress = eeReadChar();

	PowerRazvZerno = eeReadInt();

	tEndDistDefl = eeReadInt();
	minProcChimOtbSR = eeReadChar();
	PowerVarkaZerno = eeReadInt();
	TempKipenZator = eeReadInt();
	if (TempKipenZator > 1050 || TempKipenZator < 0) TempKipenZator = 800;
	TempZasypSolod = eeReadInt();
	if (TempZasypSolod>1000 || TempZasypSolod < 0) TempZasypSolod = 680;
	PowerNBK = eeReadInt();
	SpeedNBKDst = eeReadChar();
	if (PowerNBK>10000 || PowerNBK < 0) PowerNBK = 2400;
	if (SpeedNBKDst>254) SpeedNBKDst = 0;
	PowerMinute = eeReadInt();
	if (PowerMinute > 10000 || PowerMinute < 0) PowerMinute = Power;
	begProcChimOtbSR = eeReadChar();
	if (begProcChimOtbSR>100) begProcChimOtbSR = 40;
	P_MPX5010 = eeReadInt();
	if (P_MPX5010 > 800 || P_MPX5010 < -800) P_MPX5010 = 0;
	LedLight = eeReadChar();
	NaprPeregrev = eeReadInt();
	if (NaprPeregrev>1000) NaprPeregrev = 300;
	UrovenBarda = eeReadInt();
	if (UrovenBarda > 2000 || UrovenBarda < 0) UrovenBarda = 800;
	UrovenProvodimostSR = eeReadInt();
	if (UrovenProvodimostSR>2000 || UrovenProvodimostSR == -1)
	{
		UrovenProvodimostSR = 0;
	}
	TimeStabKolonna = eeReadInt();
	if (TimeStabKolonna == -1) TimeStabKolonna = 900;

	DecrementCHIM = eeReadChar();
	if (DecrementCHIM == -1) DecrementCHIM = 10;
	IncrementCHIM = eeReadChar();
	if (IncrementCHIM == -1) IncrementCHIM = 5;
	TimeAutoIncCHIM = eeReadInt();
	if (TimeAutoIncCHIM == -1) TimeAutoIncCHIM = 600;

	CntCHIM = eeReadChar();
	for (i = 0; i < COUNT_CHIM; i++)
	{
		tempK[i] = eeReadInt();
		CHIM[i] = eeReadChar();
	}
	TimeRestabKolonna = eeReadInt();
	if (TimeRestabKolonna == -1) TimeRestabKolonna = 1800;

	CntPause = eeReadChar();
	for (i = 0; i < MAX_CNT_PAUSE; i++)
	{
		// Если число пауз больше нуля, то считываем их
		if (CntPause > 0)
		{
			tempP[i] = eeReadChar();
			timeP[i] = eeReadChar();
		}
		else
		{
			// Иначе просто читаем чтобы счетчик чтений увеличился.
			eeReadChar();
			eeReadChar();
		}
		if (timeP[i] == 255) timeP[i] = 0;
	}

	if (CntPause == -1) CntPause = 8;

	CorrectASC712 = eeReadChar();
	if (CorrectASC712 == -1) CorrectASC712 = 0;

#ifdef TEST
	Serial1.print("maxaddr:");
	Serial1.println(ee_addr);
#endif  
}


void ScanKbd()
{
	char i;
#ifdef DEBUG
	if (Serial1.available()) return;
#endif

	// Если режим защиты от дребезга уже выключен
	if (CountKeys == 0)
	{
		flScanKbd = 1; // Установим признак сканирования клавиатуры.
#if USE_LCD_KEYPAD_SHIELD     
		int key1;
		key1 = analogRead(0);

		//          select 720
		//          left 478
		//          up 130 ( моргает на 131)
		//          down 306
		//          rigth 0
		//          #define PRESS_SELECT KeyCode==1
		//          #define PRESS_RIGHT  KeyCode==2
		//          #define PRESS_LEFT   KeyCode==3
		//          #define PRESS_UP     KeyCode==4
		//          #define PRESS_DOWN   KeyCode==5

		if (key1 >= 0) KeyCode = 2;
		if (key1 >= 90) KeyCode = 4;
		if (key1 >= 200) KeyCode = 5;
		if (key1 >= 400) KeyCode = 3;
		if (key1 >= 600) KeyCode = 1;
		if (key1 >= 950) KeyCode = 0;

#endif

		if (PRESS_LEFT && PRESS_RIGHT)
		{
			if (BeepKeyPress) my_beep(2);

#if USE_I2C_DISPLAY==0
			lcd.begin(16, 2);
#else
			lcd.init();
			lcd.backlight();
#endif

			lcd.clear();
			DisplayData();
		}


		// Нажатие кнопок одновременно ввехр и вниз позволяет перейти к следующему этапу (отладочные кнопки)
		if (PRESS_UP && PRESS_DOWN)
		{
			if (BeepKeyPress) my_beep(2);
			StateMachine++; // Состояние конечного автомата процесса ректификации
			CountKeys = 10; // Большая защита от дребезга, чтоб случайно не нажали.
			DisplayData();
			timeNBK = 0;
			timeMIXER = 0;
			time1 = 0;
			time2 = 0;
			time3 = 0;

		}

		if (PRESS_SELECT)
		{
			if (BeepKeyPress) my_beep(1);
			//            if (IspReg==9)
			//            {  if (FlAnIsp==0)
			//                { CountKeys=3;
			//                  FlAnIsp=1;
			//                  return;
			//                }
			//               
			//            }               
			//            FlAnIsp=0;
			switch (FlState)
			{
			case 0:

				FlState = IspReg;
				break;
			case 100:
				FlState = 200;
				break;
			case 101:
				FlState = 0;
				IspReg = 101;
				writeEEPROM();
				break;
			case 102:
				if (IspReg != 102)
				{
					Seconds = 0;
					flAlarmUroven = 0;
					StateMachine = 0;
				}
				if (!StateMachine) StateMachine = 1;
				IspReg = 102;
				writeEEPROM();
				FlState = 200;
				break;
			case 200:
				FlState = 0;
				writeEEPROM();
				break;
			case 103:
				IspReg = 103;
				writeEEPROM();
				FlState = 202;
				break;
			case 201:
				writeEEPROM();
				FlState = 0;
				break;
			case 202:
				writeEEPROM();
				FlState = 0;
				break;
			case 104:
				// Если ранее был выбран другой тип отбора, сбрасываем состояние автомата в начальное.
				if (IspReg != 104 || !StateMachine)
				{
					Seconds = 0;
					flAlarmUroven = 0;
					StateMachine = 0;
				}
				if (!StateMachine) StateMachine = 1;
				IspReg = 104;
				writeEEPROM();
				FlState = 206;
				break;
			case 105:
				// Если ранее был выбран другой тип отбора, сбрасываем состояние автомата в начальное.
				if (IspReg != 105 || !StateMachine)
				{
					Seconds = 0;
					flAlarmUroven = 0;
					StateMachine = 0;
				}
				if (!StateMachine) StateMachine = 1;
				IspReg = 105;
				writeEEPROM();
				FlState = 221;
				break;
			case 106:
				// Если ранее был выбран другой тип отбора, сбрасываем состояние автомата в начальное.
				if (IspReg != 106 || !StateMachine)
				{
					Seconds = 0;
					flAlarmUroven = 0;
					StateMachine = 0;
				}
				if (!StateMachine) StateMachine = 1;
				IspReg = 106;
				writeEEPROM();
				FlState = 207;
				break;
			case 107:
				// Если ранее был выбран другой тип отбора, сбрасываем состояние автомата в начальное.
				if (IspReg != 107 || !StateMachine)
				{
					Seconds = 0;
					flAlarmUroven = 0;
					StateMachine = 0;
				}
				if (!StateMachine) StateMachine = 1;
				IspReg = 107;
				writeEEPROM();
				FlState = 208;
				break;
			case 108:
				if (IspReg != 108 || !StateMachine)
				{
					Seconds = 0;
					flAlarmUroven = 0;
					StateMachine = 0;
				}
				if (!StateMachine) StateMachine = 1;
				IspReg = 108;
				FlState = 0;
				writeEEPROM();
				break;
			case 109:
				// Если ранее был выбран другой тип отбора, сбрасываем состояние автомата в начальное.
				if (IspReg != 109 || !StateMachine)
				{
					Seconds = 0;
					flAlarmUroven = 0;
					StateMachine = 0;
				}
				if (!StateMachine) StateMachine = 1;

				IspReg = 109;
				FlState = 209;
				writeEEPROM();
				break;
			case 110:
				// Если ранее был выбран другой тип отбора, сбрасываем состояние автомата в начальное.
				if (IspReg != 110 || !StateMachine) // Если состояние автомата - не запущено, запускаем процесс
				{
					Seconds = 0;
					flAlarmUroven = 0;
					StateMachine = 0;
				}
				if (!StateMachine) StateMachine = 1;

				IspReg = 110;
				writeEEPROM();
				FlState = 220;
				break;
			case 111:
				// Если ранее был выбран другой тип отбора, сбрасываем состояние автомата в начальное.
				if (IspReg != 111 || !StateMachine) // Если состояние автомата - не запущено, запускаем процесс
				{
					Seconds = 0;
					flAlarmUroven = 0;
					StateMachine = 0;
				}
				if (!StateMachine) StateMachine = 1;

				IspReg = 111;
				writeEEPROM();
				FlState = 209;
				break;
			case 112:
				// Если ранее был выбран другой тип отбора, сбрасываем состояние автомата в начальное.
				if (IspReg != 112 || !StateMachine) // Если состояние автомата - не запущено, запускаем процесс
				{
					Seconds = 0;
					flAlarmUroven = 0;
					StateMachine = 0;
				}
				if (!StateMachine) StateMachine = 1;

				IspReg = 112;
				writeEEPROM();
				FlState = 0;
				break;
			case 113:
				// Если ранее был выбран другой тип отбора, сбрасываем состояние автомата в начальное.
				if (IspReg != 113 || !StateMachine) // Если состояние автомата - не запущено, запускаем процесс
				{
					Seconds = 0;
					flAlarmUroven = 0;
					StateMachine = 0;
				}
				if (!StateMachine) StateMachine = 1;

				IspReg = 113;
				writeEEPROM();
				FlState = 0;
				break;
			case 114:
				// Если ранее был выбран другой тип отбора, сбрасываем состояние автомата в начальное.
				if (IspReg != 114 || !StateMachine) // Если состояние автомата - не запущено, запускаем процесс
				{
					Seconds = 0;
					flAlarmUroven = 0;
					StateMachine = 0;
				}
				if (!StateMachine) StateMachine = 1;

				IspReg = 114;
				writeEEPROM();
				FlState = 0;
				break;
			case 115:
				// Если ранее был выбран другой тип отбора, сбрасываем состояние автомата в начальное.
				if (IspReg != 115 || !StateMachine) // Если состояние автомата - не запущено, запускаем процесс
				{
					Seconds = 0;
					flAlarmUroven = 0;
					StateMachine = 0;
				}
				if (!StateMachine) StateMachine = 1;

				IspReg = 115;
				writeEEPROM();
				FlState = 0;
				break;
			case 116:
				// Если ранее был выбран другой тип отбора, сбрасываем состояние автомата в начальное.
				if (IspReg != 116 || !StateMachine) // Если состояние автомата - не запущено, запускаем процесс
				{
					Seconds = 0;
					flAlarmUroven = 0;
					StateMachine = 0;
				}
				if (!StateMachine) StateMachine = 1;

				IspReg = 116;
				writeEEPROM();
				FlState = 240;
				break;
			case 130:
				if (IspReg != 130 || !StateMachine)
				{
					Seconds = 0;
					flAlarmUroven = 0;
					StateMachine = 0;
				}
				if (!StateMachine) StateMachine = 1;
				IspReg = 130;
				writeEEPROM();
				FlState = 0;
				break;
			case 129:
				if (IspReg != 129 || !StateMachine)
				{
					Seconds = 0;
					flAlarmUroven = 0;
					StateMachine = 0;
				}
				if (!StateMachine) StateMachine = 1;
				IspReg = 129;
				writeEEPROM();
				FlState = 0;
				break;
			case 203:
			case 204:
			case 205:
			case 206:
			case 207:
			case 208:
			case 209:
			case 210:
				//      case 211:             
			case 212:
			case 213:
			case 214:
			case 215:
			case 216:
			case 217:
			case 218:
			case 219:
			case 220:
			case 221:
			case 222:
			case 223:
			case 224:
			case 225:
			case 226:
			case 227:
			case 228:
			case 229:
			case 230:
			case 231:
			case 232:
			case 233:
			case 234:
			case 236:
			case 237:
			case 238:
			case 239:
			case 241:
			case 250:
			case 251:
			case 252:
			case 253:
				writeEEPROM();
				FlState = 0;
				break;
			case 211:
				FlState = 300;
				nPopr = 0;
				break;
			case 235:
				FlState = 301;
				nPopr = 0;
				flPopr = 0;
				break;
			case 240:
				FlState = 302;
				nPopr = 0;
				flPopr = 0;
				break;
			case 300:
				writeEEPROM();
				FlState = 211;
				break;
			case 301:
				writeEEPROM();
				FlState = 235;
				break;
			case 302:
				writeEEPROM();
				if (IspReg != 116) FlState = 240;
				else FlState = 0;
				break;
			}
			DisplayData();
			CountState = 4;
			if (CountKeys == 0) CountKeys = 6;
			CountState = 10;

		}

		// Вторая  кнопка ( кнопка -)        
		if (PRESS_RIGHT)
		{
			if (BeepKeyPress) my_beep(1);
			switch (FlState)
			{
			case 0:
				if (DispPage < 9) DispPage++;
				// Если перешли на третью страницу, то переинициализируем дисплей
				if (DispPage == 4 || DispPage == 9)
				{
					my_beep(50);
#if USE_I2C_DISPLAY==0
					lcd.begin(16, 2);
#else
					lcd.init();
					lcd.backlight();
#endif

					lcd.clear();
					DisplayData();
				}
				CountKeys = 4;
				break;
			case 100:
			case 101:
			case 102:
			case 103:
			case 104:
			case 105:
			case 106:
			case 107:
			case 108:
			case 109:
			case 110:
			case 111:
			case 112:
			case 113:
			case 114:
			case 115:
			case 129:
				FlState++;
				break;
			case 116:
				FlState = 129;
				break;
			case 130:
				FlState = 100;
				break;
			case 200:
			case 201:
			case 202:
			case 203:
			case 204:
			case 205:
			case 206:
			case 207:
			case 208:
			case 209:
			case 210:
			case 211:
			case 212:
			case 213:
			case 214:
			case 215:
			case 216:
			case 217:
			case 218:
			case 219:
			case 220:
			case 221:
			case 222:
			case 223:
			case 224:
			case 225:
			case 226:
			case 227:
			case 228:
			case 229:
			case 230:
			case 231:
			case 232:
			case 233:
			case 234:
			case 235:
			case 236:
			case 237:
			case 238:
			case 239:
			case 240:
			case 250:
			case 251:
			case 252:
				FlState++;
				break;
			case 241:
				FlState = 250;
				break;
			case 253:
				FlState = 200;
				break;
			case 300:
				if (nPopr < MAX_DS1820 - 1) nPopr++;
				break;
			case 301:
				if (flPopr == 0) flPopr = 1;
				else
				{
					if (nPopr < COUNT_CHIM - 1) nPopr++;
					flPopr = 0;

				}
				break;
			case 302:
				if (flPopr == 0) flPopr = 1;
				else
				{
					if (nPopr < MAX_CNT_PAUSE - 1) nPopr++;
					flPopr = 0;

				}
				break;
			}

			//NeedDisplaying=1;
			DisplayData();
			if (CountKeys == 0) CountKeys = 6;

			CountState = 4;
			CountState = 40;


		}

		// первая  кнопка  (кнопка +)      

		if (PRESS_LEFT)
		{
			if (BeepKeyPress) my_beep(1);
			switch (FlState)
			{

			case 0:
				if (DispPage > 0) DispPage--;
				else
				{ // Если на нулевой странице нажали кнопку влево, то тоже переинициализируем дисплей. 
					my_beep(50);
#if USE_I2C_DISPLAY==0
					lcd.begin(16, 2);
#else
					lcd.init();
					lcd.backlight();
#endif

					lcd.clear();
					DisplayData();
				}

				CountKeys = 4;
				break;
			case 100:
				FlState = 130;
				break;
			case 101:
			case 102:
			case 103:
			case 104:
			case 105:
			case 106:
			case 107:
			case 108:
			case 109:
			case 110:
			case 111:
			case 112:
			case 113:
			case 114:
			case 115:
			case 116:
			case 130:
				FlState--;
				break;
			case 129:
				FlState = 116;
				break;
			case 201:
			case 202:
			case 203:
			case 204:
			case 205:
			case 206:
			case 207:
			case 208:
			case 209:
			case 210:
			case 211:
			case 212:
			case 213:
			case 214:
			case 215:
			case 216:
			case 217:
			case 218:
			case 219:
			case 220:
			case 221:
			case 222:
			case 223:
			case 224:
			case 225:
			case 226:
			case 227:
			case 228:
			case 229:
			case 230:
			case 231:
			case 232:
			case 233:
			case 234:
			case 235:
			case 236:
			case 237:
			case 238:
			case 239:
			case 240:
			case 241:
			case 251:
			case 252:
			case 253:
				FlState--;
				break;
			case 250:
				FlState = 241;
				break;
			case 200:
				FlState = 253;
				break;
			case 300:
				if (nPopr > 0) nPopr--;
				break;
			case 301:
				if (flPopr == 1) flPopr = 0;
				else
				{
					if (nPopr > 0) nPopr--;
					flPopr = 1;
				}
				break;
			case 302:
				if (flPopr == 1) flPopr = 0;
				else
				{
					if (nPopr > 0) nPopr--;
					flPopr = 1;
				}
				break;
			}

			//NeedDisplaying=1;
			DisplayData();
			flNeedAnalyse = 1;
			CountState = 4;
			CountState = 40;
			if (CountKeys == 0) CountKeys = 6;
		}



		if (PRESS_UP)
		{
			if (BeepKeyPress) my_beep(1);
			CountState = 0;
			switch (FlState)
			{
			case 0:
				// В сотоянии 0 обработка клавиш происходит за выходом модели этого конечного автомата.
				if (DispPage == 7) // На 8 странице вручную можно состояние процесса поменять
				{
					StateMachine++;
					break;
				}

				if (DispPage == 5) // На 6 странице можно мощность внучную привбавить
				{
					UstPower += 10;
					break;
				}

				// Ректификация
				if (IspReg == 109)
				{
					switch (StateMachine)
					{
					case 2:
						tEndRectRazgon++;
						break;
					case 3:
						PowerRect += 10;
						CountKeys = 3;
						break;
					case 4:
						tEndRectOtbGlv++;
						break;
					case 5:
						tStabSR++;
						break;
					case 6:
						ProcChimSR++;
						break;
					case 7:
						tEndRect++;
						break;
					}
				}

				// Регулятор мощности
				if (IspReg == 103)
				{
					if (SlaveON == 0) UstPowerReg += 10;
					if (SlaveON == 2) PowerGlvDistil += 10;
					if (SlaveON == 3) PowerRect += 10;
					if (SlaveON == 4) PowerDistil += 10;

					//TekPower=(unsigned long) UstPower*220*220/ Power;
					CountKeys = 3;
				}

				if (IspReg == 104)
				{
					if (StateMachine == 2)
						TempDeflBegDistil++;
					else
					{
						if (DispPage == 0)  Temp1P++;
						else  PowerDistil += 10;
					}
				}
				if (IspReg == 106)
				{
					if (StateMachine == 2)
						TempDeflBegDistil++;
					else
					{
						if (DispPage == 0)  Temp2P++;
						else PowerDistil += 10;
					}
				}

				if (IspReg == 107)
				{
					if (StateMachine == 2)
						TempDeflBegDistil++;
					else
					{
						if (DispPage == 0)  Temp3P++;
						else  PowerDistil += 10;
					}
				}

				if (IspReg == 105)
				{
					if (StateMachine == 4) PowerGlvDistil += 10;
					if (StateMachine == 2 || StateMachine == 3) TempDeflBegDistil++;
				}

				if (IspReg == 114)
				{
					TempHLDZatorBrog++;
				}

				if (IspReg == 129)
				{
					CloseAllKLP();
					ProcChimSR++;
				}

				if (IspReg == 115)
				{
					if (DispPage == 0) timerMinute++;
					else  PowerMinute += 10;
				}

				if (IspReg == 116)
				{
					if (DispPage == 0 && StateMachine == 3 && timeP[KlTek] == 0) timeP[KlTek] = 255;
				}

				if (IspReg == 108 || IspReg == 113)
				{
					switch (StateMachine)
					{
					case 0: //Не запущено
					case 1: //Нагрев до температуры 50 градусов
					case 2: //Поддержание температуры 50 градусов, пока не произойдет ручной переход к следующему этапу.
					case 4: //Ожидание 15 минут, поддержка температуры
					case 6: //Варка
					case 9: //Размешивание после засыпания солшода
					case 10: // Осахаривание
						if (DispPage == 0) time2 += 60;
						else TempZasypSolod += 5;
						break;
					case 5: //  Нагрев до закипания
						TempKipenZator++;
						break;
					case 7: //охлаждение до температуры осахаривания.
						TempZasypSolod++;
						break;
					case 12: //охлаждение до температуры осахаривания.
						TempHLDZatorBrog++;
						break;
					case 8: //ожидание засыпки солода, поддержка температуры
						StateMachine = 9;
						CountKeys = 6;
						break;
					case 3: //Нагрев до температуры 62 градуса
						if (DispPage == 0) PowerVarkaZerno += 10;
						else TempZasypSolod += 5;

						break;
					case 100: //Окончание
						break;
					}
				}

				if (IspReg == 110)
				{
					if (StateMachine == 2)
						TempDeflBegDistil++;
					else
						if (DispPage == 0) TempDefl++;
						else deltaPower += 10;
				}

				// НДРФ
				if (IspReg == 111)
				{
					switch (StateMachine)
					{
					case 2:
						tEndRectRazgon++;
						break;
					case 3:
						if (DispPage == 0) SecOstatok += 60;
						else PowerRect += 10;
						CountKeys = 3;
						break;
					case 4:
						tEndRectOtbGlv++;
						break;
					case 5:
						tStabSR++;
						break;
					case 6:
						ProcChimSR++;
						break;
					case 7:
						tEndRect++;
						break;
					}
				}
				// NBK
				if (IspReg == 112)
				{
					if (DispPage == 0)
					{
						if (StateMachine == 3) StateMachine = 4;
						else
						{
							SpeedNBKDst += 1;
							SpeedNBK = SpeedNBKDst;
						}
					}
					else
					{
						PowerNBK += 10;
						UstPower = PowerNBK;
					}
				}

				break;
			case 200:
				TempTerm++;
				CountKeys = 3;
				break;
			case 201:
				Power += 10;
				CountKeys = 3;
				break;
			case 202:
				UstPowerReg += 10;
				CountKeys = 3;
				break;
			case 203:
				FlToUSART = 1;
				break;
			case 204:
				FlToGSM = 1;
				// Переинициализируем сотовый
				InitGSM();
				break;
			case 205:
				Delta++;
				CountKeys = 3;
				break;
			case 206:
				Temp1P++;
				CountKeys = 3;
				break;
			case 207:
				Temp2P++;
				CountKeys = 3;
				break;
			case 208:
				Temp3P++;
				CountKeys = 3;
				break;
			case 209:
				if (tEndRectRazgon < 920)
					tEndRectRazgon++;
				CountKeys = 3;
				break;
			case 210:
				PowerRect += 10;
				CountKeys = 3;
				break;
			case 212:
				tEndRectOtbGlv++;
				CountKeys = 3;
				break;
			case 213:
				timeChimRectOtbGlv += 10;
				CountKeys = 3;
				break;
			case 214:
				ProcChimOtbGlv++;
				CountKeys = 4;
				break;
			case 250:
				minProcChimOtbSR++;
				CountKeys = 4;
				break;
			case 251:
				tStabSR++;
				CountKeys = 3;
				break;
			case 252:
				begProcChimOtbSR++;
				CountKeys = 4;
				break;
			case 253:
				P_MPX5010++;
				CountKeys = 4;
				break;
			case 215:
				timeChimRectOtbSR += 10;
				CountKeys = 3;
				break;
			case 216:
				tDeltaRect++;
				CountKeys = 4;
				break;
			case 217:
				tEndRectOtbSR++;
				CountKeys = 3;
				break;
			case 218:
				tEndRect++;
				CountKeys = 3;
				break;
			case 219:
				PowerGlvDistil += 10;
				CountKeys = 3;
				break;
			case 220:
				PowerDistil += 10;
				CountKeys = 3;
				break;
			case 221:
				TempDeflBegDistil++;
				CountKeys = 3;
				break;
			case 222:
				TempDefl++;
				CountKeys = 3;
				break;
			case 223:
				DeltaDefl++;
				CountKeys = 3;
				break;
			case 224:
				tEndDistDefl++;
				CountKeys = 3;
				break;
			case 225:
				BeepEndProcess = 1;
				break;
			case 226:
				BeepStateProcess = 1;
				break;
			case 227:
				BeepKeyPress = 1;
				break;
			case 228:
				PowerRazvZerno += 10;
				CountKeys = 3;
				break;
			case 229:
				PowerVarkaZerno += 10;
				CountKeys = 3;
				break;
			case 230:
				LedLight += 10;
				CountKeys = 3;
				break;
			case 231:
				NaprPeregrev += 5;
				CountKeys = 3;
				break;
			case 232:
				UrovenBarda += 5;
				CountKeys = 3;
				break;
			case 233:
				UrovenProvodimostSR++;
				CountKeys = 3;
				break;
			case 234:
				TimeStabKolonna += 60;
				CountKeys = 3;
				break;
			case 235:
				CntCHIM++;
				CountKeys = 3;
				break;
			case 236:
				DecrementCHIM++;
				CountKeys = 3;
				break;
			case 237:
				IncrementCHIM++;
				CountKeys = 3;
				break;
			case 238:
				TimeAutoIncCHIM += 60;
				CountKeys = 3;
				break;
			case 239:
				TimeRestabKolonna += 60;
				CountKeys = 3;
				break;
			case 240:
				CntPause++;
				CountKeys = 3;
				break;
			case 241:
				CorrectASC712++;
				CountKeys = 3;
				break;

			case 300:
				ds1820_popr[nPopr]++;
				CountState = 8; // При вводе поправок сохраняем состояние 4 секунды, а не две, тут спешка не нужна.                
				CountKeys = 4;
				break;
			case 301:
				if (flPopr == 0) {
					if (tempK[nPopr] < 770) tempK[nPopr] = 770;
					else tempK[nPopr]++;
					CountKeys = 1;
				}
				else CHIM[nPopr]++;
				break;
			case 302:
				if (flPopr == 0) tempP[nPopr]++;
				else
				{
					timeP[nPopr]++;
					if (timeP[nPopr] == 255) timeP[nPopr] = 0;
				}
				break;
			}

			//NeedDisplaying=1;
			DisplayData();
			flNeedAnalyse = 1;
			if (CountState == 0) CountState = 4;
			if (CountKeys == 0) CountKeys = 6;
			CountState = 40;
		}


		if (PRESS_DOWN)
		{
			if (BeepKeyPress) my_beep(1);
			CountState = 0;
			switch (FlState)
			{
			case 0:

				// В сотоянии 0 обработка клавиш происходит за выходом модели этого конечного автомата.
				if (DispPage == 2) // На третьей странице сбрасываем датчик потока
				{
					FlowCount = 0;
					break;
				}

				if (DispPage == 7) // На 8 странице можно состояние процесс поменять.
				{
					StateMachine--;
					break;
				}

				if (DispPage == 5) // На 6 странице можно мощность вручную изменить.
				{
					UstPower -= 10;
					break;
				}

				// Ректификация
				if (IspReg == 109)
				{
					switch (StateMachine)
					{
					case 2:
						tEndRectRazgon--;
						break;
					case 3:
						PowerRect -= 10;
						CountKeys = 3;
						break;
					case 4:
						tEndRectOtbGlv--;
						break;
					case 5:
						tStabSR--;
						break;
					case 6:
						ProcChimSR--;
						break;
					case 7:
						tEndRect--;
						break;
					}
				}

				// Регулятор мощности
				if (IspReg == 103)
				{
					if (SlaveON == 0) UstPowerReg -= 10;
					if (SlaveON == 2) PowerGlvDistil -= 10;
					if (SlaveON == 3) PowerRect -= 10;
					if (SlaveON == 4) PowerDistil -= 10;

					//TekPower=(unsigned long) UstPower*220*220/ Power;
					CountKeys = 3;
				}
				if (IspReg == 104)
				{
					if (StateMachine == 2)
						TempDeflBegDistil--;
					else
						if (DispPage == 0)  Temp1P--;
						else  PowerDistil -= 10;
				}
				if (IspReg == 106)
				{
					if (StateMachine == 2)
						TempDeflBegDistil--;
					else
						if (DispPage == 0)  Temp2P--;
						else  PowerDistil -= 10;
				}

				if (IspReg == 107)
				{
					if (StateMachine == 2)
						TempDeflBegDistil--;
					else
						if (DispPage == 0)  Temp3P--;
						else  PowerDistil -= 10;
				}

				if (IspReg == 105)
				{
					if (StateMachine == 4) PowerGlvDistil -= 10;
					if (StateMachine == 2 || StateMachine == 3) TempDeflBegDistil--;
				}

				if (IspReg == 114)
				{
					TempHLDZatorBrog--;
				}

				if (IspReg == 129)
				{
					CloseAllKLP();
					ProcChimSR--;
				}

				if (IspReg == 115)
				{
					if (DispPage == 0) timerMinute--;
					else  PowerMinute -= 10;
				}
				if (IspReg == 108 || IspReg == 113)
				{
					switch (StateMachine)
					{
					case 0: //Не запущено
					case 1: //Нагрев до температуры 50 градусов
					case 2: //Поддержание температуры 50 градусов, пока не произойдет ручной переход к следующему этапу.
					case 4: //Ожидание 15 минут, поддержка температуры
					case 6: //Варка
					case 9: //Размешивание после засыпания солшода
					case 10: // Осахаривание
						if (DispPage == 0)
						{
							if (time2 >= 65) time2 -= 60;
							else time2 = 0;

						}
						else TempZasypSolod -= 5;

						break;
					case 5:
						TempKipenZator--;
						break;
					case 12: //охлаждение до температуры осахаривания.
						TempHLDZatorBrog--;
						break;
					case 7: //охлаждение до температуры осахаривания.
						TempZasypSolod--;
						break;
					case 3: //Нагрев до температуры 62 градуса
						if (DispPage == 0) PowerVarkaZerno -= 10;
						else TempZasypSolod -= 5;
						break;
					case 100: //Окончание
						break;
					}
				}

				if (IspReg == 110)
				{
					if (StateMachine == 2)
						TempDeflBegDistil--;
					else
						if (DispPage == 0) TempDefl--;
						else deltaPower -= 10;

				}

				// НДРФ
				if (IspReg == 111)
				{
					switch (StateMachine)
					{
					case 2:
						tEndRectRazgon--;
						break;
					case 3:
						if (DispPage == 0) SecOstatok -= 60;
						else PowerRect -= 10;
						CountKeys = 3;
						break;
					case 4:
						tEndRectOtbGlv--;
						break;
					case 5:
						tStabSR--;
						break;
					case 6:
						ProcChimSR--;
						break;
					case 7:
						tEndRect--;
						break;
					}
				}
				// NBK
				if (IspReg == 112)
				{
					if (DispPage == 0)
					{
						SpeedNBKDst -= 1;
						SpeedNBK = SpeedNBKDst;
					}
					else
					{
						PowerNBK -= 10;
						UstPower = PowerNBK;
					}
				}


				break;
			case 200:
				TempTerm--;
				CountKeys = 3;
				break;
			case 201:
				Power -= 10;
				CountKeys = 3;
				break;
			case 202:
				UstPowerReg -= 10;
				CountKeys = 3;
				break;
			case 203:
				FlToUSART = 0;
				break;
			case 204:
				FlToGSM = 0;
				break;
			case 205:
				Delta--;
				CountKeys = 3;
				break;
			case 206:
				Temp1P--;
				CountKeys = 3;
				break;
			case 207:
				Temp2P--;
				CountKeys = 3;
				break;
			case 208:
				Temp3P--;
				CountKeys = 3;
				break;
			case 209:
				if (tEndRectRazgon > 600)
					tEndRectRazgon--;
				CountKeys = 3;
				break;
			case 210:
				PowerRect -= 10;
				CountKeys = 3;
				break;
			case 212:
				tEndRectOtbGlv--;
				CountKeys = 3;
				break;
			case 213:
				timeChimRectOtbGlv -= 10;
				CountKeys = 3;
				break;
			case 214:
				ProcChimOtbGlv--;
				CountKeys = 4;
				break;
			case 250:
				minProcChimOtbSR--;
				CountKeys = 4;
				break;
			case 251:
				tStabSR--;
				CountKeys = 3;
				break;
			case 252:
				begProcChimOtbSR--;
				CountKeys = 4;
				break;
			case 253:
				P_MPX5010--;
				CountKeys = 4;
				break;
			case 215:
				timeChimRectOtbSR -= 10;
				CountKeys = 3;
				break;
			case 216:
				tDeltaRect--;
				CountKeys = 4;
				break;
			case 217:
				tEndRectOtbSR--;
				CountKeys = 3;
				break;
			case 218:
				tEndRect--;
				CountKeys = 3;
				break;
			case 219:
				PowerGlvDistil -= 10;
				CountKeys = 3;
				break;
			case 220:
				PowerDistil -= 10;
				CountKeys = 3;
				break;
			case 221:
				TempDeflBegDistil--;
				CountKeys = 3;
				break;
			case 222:
				TempDefl--;
				CountKeys = 3;
				break;
			case 223:
				DeltaDefl--;
				CountKeys = 3;
				break;
			case 224:
				tEndDistDefl--;
				CountKeys = 3;
				break;
			case 225:
				BeepEndProcess = 0;
				break;
			case 226:
				BeepStateProcess = 0;
				break;
			case 227:
				BeepKeyPress = 0;
				break;
			case 228:
				PowerRazvZerno -= 10;
				CountKeys = 3;
				break;
			case 229:

				if (PowerVarkaZerno > 10) PowerVarkaZerno -= 10;
				else PowerVarkaZerno = 0;


				CountKeys = 3;
				break;
			case 230:
				LedLight -= 10;
				CountKeys = 3;
				break;
			case 231:
				NaprPeregrev -= 5;
				CountKeys = 3;
				break;
			case 232:
				UrovenBarda -= 5;
				CountKeys = 3;
				break;
			case 233:
				UrovenProvodimostSR--;
				CountKeys = 3;
				break;
			case 234:
				TimeStabKolonna -= 60;
				CountKeys = 3;
				break;
			case 235:
				CntCHIM--;
				CountKeys = 3;
				break;
			case 236:
				DecrementCHIM--;
				CountKeys = 3;
				break;
			case 237:
				IncrementCHIM--;
				CountKeys = 3;
				break;
			case 238:
				TimeAutoIncCHIM -= 60;
				CountKeys = 3;
				break;
			case 239:
				TimeRestabKolonna -= 60;
				CountKeys = 3;
				break;
			case 240:
				CntPause--;
				CountKeys = 3;
				break;
			case 241:
				CorrectASC712--;
				CountKeys = 3;
				break;

			case 300:
				ds1820_popr[nPopr]--;
				CountState = 8; // При вводе поправок сохраняем состояние 4 секунды, а не две, тут спешка не нужна.                
				CountKeys = 4;
				break;
			case 301:
				if (flPopr == 0) { tempK[nPopr]--; CountKeys = 1; }
				else CHIM[nPopr]--;
				break;
			case 302:
				if (flPopr == 0) tempP[nPopr]--;
				else
				{
					timeP[nPopr]--;
					if (timeP[nPopr] == 255) timeP[nPopr] = 254;
				}
				break;


			}

			//NeedDisplaying=1;
			DisplayData();
			flNeedAnalyse = 1;
			if (CountState == 0) CountState = 4;
			if (CountKeys == 0) CountKeys = 6;
			CountState = 40;
		}
		flNeedScanKbd = 0;
		flScanKbd = 0; // Убираем признак того, что сканируется клавиатура.
	}
}


// Функция возвращает значение ШИМ для отборв по "шпоре" (температуре в кубе)
char GetCHIMOtbor()
{
	// Процент отбора задается в табличном виде, например в данном случае 
	// от 0 до 88 в кубе процент отбора не меняем, от 88.0 до 96.0 в кубе процент отбора ставить в промежутке от 68 до 25
	// от 960 до 1000 процент отбора понижаем до нуля.
	// здесь храним количество значений в таблице;
	char FindCHIM;
	char i;
#ifdef TEST
	Serial1.print("KUB=");
	Serial1.print(temps[TEMP_KUB]);
#endif

	FindCHIM = ProcChimSR;
	for (i = 1; i < CntCHIM; i++)
	{
		if (tempK[i - 1] <= temps[TEMP_KUB] && tempK[i] > temps[TEMP_KUB])
		{
			// Если отбор при этом диапазоне температур производим
			if (CHIM[i - 1] > 0)
			{
				FindCHIM = (temps[TEMP_KUB] - tempK[i - 1])*(int)(CHIM[i] - CHIM[i - 1]) / (tempK[i] - tempK[i - 1]) + (int)CHIM[i - 1];
#ifdef TEST
				Serial1.print(" CHIM=");
				Serial1.println((int)FindCHIM);
#endif
				return FindCHIM; // Теперь возвращаем новое значение ШИМ в любом случае. 
			}

		}
	}

#ifdef TEST
	Serial1.println(" noFindCHIM");
#endif

	return ProcChimSR;
}

void ProcessRectif()
{

	//#define KLP_NPG  0      // Номер клапана для управления НПГ (при дистилляции) 
	//#define KLP_VODA 1      // Номер клапана для управления общей подачей воды в систему
	//#define KLP_DEFL 2      // Номер клапана для подачи воды в дейфлегматор
	//#define KLP_GLV_HVS  3       // Номер клапана отбора головных и хвостовых фракций
	//#define KLP_SR   4      // Номер клапана отбора ректификата
	//#define TEMP_KUB  0      // Номер датчика  термометра в кубе
	//#define TEMP_RK20 1      // Номер датчика термометра в РК 20 см от насадки
	//#define TEMP_TSA  2      // Номер термометра в трубке связи с атмосферой
	static char Count_Provodimost = 0; // Количество срабатываний датчика проводимости для окончания отбора голов.
	static char OldStateMachine = 0; // Количество срабатываний датчика проводимости для окончания отбора голов.
	int V3; // Текущий уровень проводимости;

	if (flAlarmUroven && StateMachine < 8)
	{ // Переводим автомат в стадию завершения 
		if (USE_ALARM_UROVEN == 1)
		{
			StateMachine = 8; // Переводим в режим окончания
			SecTempPrev = Seconds;// Запомним время, когда закончилась ректификация
			if (BeepStateProcess) my_beep(BEEP_LONG);
		}
		else
		{
			OldStateMachine = StateMachine;
			StateMachine = 9;  // Переводим в режим ожидания
			if (BeepStateProcess) my_beep(BEEP_LONG);
			Count_Provodimost = 0;
			KlOpen[KLP_GLV_HVS] = 0;
			KlClose[KLP_GLV_HVS] = 100;
			KlOpen[KLP_SR] = 0;
			KlClose[KLP_SR] = 100;
		}

	}

	// Проверяем температуру в ТСА
	if (temps[TEMP_TSA] >= MAX_TEMP_TSA)
	{
		StateMachine = 101; // Переводим автомат в состояние аварии по ТСА.
	}


	switch (StateMachine)
	{
	case 0: // Процесс не запущен
		break;
	case 1: // Начало процесса
		PrepareProcess();
		KlReg[KLP_GLV_HVS] = PEREGREV_ON;
		KlReg[KLP_SR] = PEREGREV_ON;

		//          if (FlToGSM && lastSMSState!=StateMachine) StateToSMS();
		lastSMSState = 0;
		KlOpen[KLP_VODA] = PER_KLP_OPEN;
		KlClose[KLP_VODA] = PER_KLP_CLOSE;
		//    digitalWrite(PIN_REG_ON,HIGH);
		digitalWrite(PIN_RZG_ON, RELAY_HIGH);
		digitalWrite(PIN_ALL_OFF, !ALL_OFF_HIGH);
		flAllOff = 0;
		StateMachine = 2;
		if (BeepStateProcess) my_beep(BEEP_LONG);
		Count_Provodimost = 0;
		if (CntCHIM < 0) CntCHIM = -1;

	case 2: // Разгон
		UstPower = Power; // Устанавливаем максимальную мощность для разгона
		// Подчиненные контроллеры переводим в разгон
		digitalWrite(PIN_SLAVE_0, 1);
		digitalWrite(PIN_SLAVE_1, 0);
		digitalWrite(PIN_SLAVE_2, 0);
		digitalWrite(PIN_SLAVE_3, 0);

		// Учитываем как температуру в кубе, так и температуру в колонне.
		if (temps[TEMP_KUB] < tEndRectRazgon && temps[TEMP_RK20] < 600) break;

		// Подаем питание на клапан дефлегматора
		KlOpen[KLP_DEFL] = PER_KLP_OPEN;
		KlClose[KLP_DEFL] = PER_KLP_CLOSE;
		TempPrev = temps[TEMP_RK20];
		SecTempPrev = Seconds; // Запоминаем дату последнего изменения температуры
		StateMachine = 3;
		digitalWrite(PIN_RZG_ON, !RELAY_HIGH);
		if (BeepStateProcess) my_beep(BEEP_LONG);
	case 3:// Стабилизация температуры
		UstPower = PowerRect;
		// Подчиненные контроллеры переводим в ректификацию
		digitalWrite(PIN_SLAVE_0, 1);
		digitalWrite(PIN_SLAVE_1, 1);
		digitalWrite(PIN_SLAVE_2, 0);
		digitalWrite(PIN_SLAVE_3, 0);

		if (temps[TEMP_RK20] > 500) // Если температура больше 70 градусов (вдруг куб прогрелся, а колонна еще нет, нелогично, конечно, но на всякий случай учтем)
		{
			if (TimeStabKolonna >= 0)  // Если время стабилизации колонны больше нуля, то тогда считаем время относительно последнего изменения температуры
			{
				if (abs(temps[TEMP_RK20] - TempPrev) < 2) //Если текущая температура колонны равна температуре, запомненной ранее за исключением погрешности 0,2 градуса
				{
					if (Seconds - SecTempPrev > TimeStabKolonna) //Если с момента последнего измерения прошло более 600 секунд (10 минут), тогда считаем, что температура в колоенне стабилизировалась
					{
						// Переходим к следующему этапу - отбору голов. 
						StateMachine = 4;
						if (BeepStateProcess) my_beep(BEEP_LONG);
						SecTempPrev = Seconds;
					}
					else
						break;

				}
				else
				{
					TempPrev = temps[TEMP_RK20];// Запоминаем температуру
					SecTempPrev = Seconds; // Запоминаем время последнего изменения температуры
					break;
				}
			}
			else
			{
				// Если время стабилизации колонны меньше нуля, то тогда считаем абсолютное время 
				if (Seconds - SecTempPrev > -TimeStabKolonna) //Если с момента начала стабилизации прошло больше заданного количества секунд
				{
					// Переходим к следующему этапу - отбору голов. 
					StateMachine = 4;
					if (BeepStateProcess) my_beep(BEEP_LONG);
					SecTempPrev = Seconds;
				}
				else
					break;
			}
		}
		else
			break;
	case 4: // Отбор голов
		UstPower = PowerRect;
		// Подчиненные контроллеры переводим в ректификацию
		digitalWrite(PIN_SLAVE_0, 1);
		digitalWrite(PIN_SLAVE_1, 1);
		digitalWrite(PIN_SLAVE_2, 0);
		digitalWrite(PIN_SLAVE_3, 0);

		//unsigned int timeChimRectOtbGlv=2000;  // Шим отбора голов (в полупериодах сетевого напряжения в данном случае это около 20 секунд)
		//unsigned char ProcChimOtbGlv=5;  // Процент ШИМ отбора голов (в данном случае это 5 процентов)
		// Клапан отбора ректификата закроем на всякий случай
		KlOpen[KLP_SR] = 0;
		KlClose[KLP_SR] = 10;

		// Устанавливаем клапан отбора хвостов и голов в соответвии с установленнным ШИМ
		//int tEndRectOtbGlv=854;     // Температура окончания отбора голов 85.4 С
		KlOpen[KLP_GLV_HVS] = ((timeChimRectOtbGlv / 10)*ProcChimOtbGlv) / 10;
		KlClose[KLP_GLV_HVS] = timeChimRectOtbGlv - KlOpen[KLP_GLV_HVS];
		tStabSR = temps[TEMP_RK20];// Это температура, относительно которой будем стабилизировать отбор

		if (UrovenProvodimostSR == 0) // Если проводимость спирта не используется, головы отбираем по температуре
		{
			if (temps[TEMP_KUB] < tEndRectOtbGlv)
			{  // Пока температура в кубе не выросла выше окончания отбора голов, продолжаем это состояни
				break;
			}
		}
		else
		{

			if (UrovenProvodimostSR > 0) // Если проводимость больше нуля, используем проводимость в том или ином виде
			{
				V3 = U_GLV;
				// Если проводимость менее заданного уровня, и проводимость вообще сущетвует, то увеличиваем счетчик срабатываний
				// или ести проводимость больше уровня тревоги и установлен признак отбирать головы по уровню в приемной емкости.

				if ((V3 < UrovenProvodimostSR && V3 >= 2 && UrovenProvodimostSR >= 5) || (V3 >= UROVEN_ALARM && UrovenProvodimostSR <= 2))
					Count_Provodimost++;
				else
					Count_Provodimost = 0;

				// Если счетчик срабатываний не превысил максимальное число раз, тогда продолжаем процесс отбора голов.
				if (Count_Provodimost < MAX_COUNT_PROVODIMOST_SR) break;
			}
			else // Если уровень проводимости SR меньше нуля, тогда это означает, что отбор голов производится по времени (в десятках минут).
			{
				// Анализируем, сколько минут прошло с начала отбора голов.
				SecOstatok = -((Seconds - SecTempPrev) / 600 + UrovenProvodimostSR);
				if (SecOstatok > 0) break;
			}
		}

		// Если температура превысила указанный рубеж, то переходим в состояние отбора спирта-ректификата.
		// Клапан отбора голов и хвостов отключаем
		tStabSR = temps[TEMP_RK20];// Это температура, относительно которой будем стабилизировать отбор
		KlOpen[KLP_GLV_HVS] = 0;
		KlClose[KLP_GLV_HVS] = 10;
		ProcChimSR = begProcChimOtbSR;
		StateMachine = 5;
		if (BeepStateProcess) my_beep(BEEP_LONG);

	case 5: // Ожидание, пока температура не вернется к состоянию стабилизации
		// Это для отладки страт-стопа, на самом деле температура 28,5 градуса в этом режиме в колонне быть не может
		if (tStabSR == 0) tStabSR = 285;
		// Если колонна слишком долго находится в режиме стопа, то температуру стабилизации примем за новую
		if (time1 == 0 && TimeRestabKolonna > 0)
		{
			tStabSR = temps[TEMP_RK20];// Это температура, относительно которой будем стабилизировать отбор
			if (BeepStateProcess) my_beep(BEEP_LONG);
		}

		KlOpen[KLP_SR] = 0;
		KlClose[KLP_SR] = 10;
		if (temps[TEMP_KUB] >= tEndRectOtbSR)
		{
			StateMachine = 7;
			if (BeepStateProcess) my_beep(BEEP_LONG);
			break;
		}

		if (temps[TEMP_RK20] > tStabSR)
		{
			break;
		}
		SecTempPrev = Seconds;// Запомним время, когда стабилизировалась температура
		StateMachine = 6;
		if (BeepStateProcess) my_beep(BEEP_LONG);
	case 6: // Отбор СР
		//unsigned int timeChimRectOtbSR=1000;  // Шим отбора СР (в полупериодах сетевого напряжения в данном случае это около 10 секунд)
		//unsigned char tDeltaRect=10;  // Дельта ректификации (в десятых градуса Цельсия) в данном случае - это 10 десятых, то есть 1 градус Цельсия
		//unsigned int tEndRectOtbSR=965;  // Температура окончания отбора спирта-ректификата и начала отбора хвостов (в данном случе 96.5 С)
		// Клапан отбора голов закроем на всякий случай
		KlOpen[KLP_GLV_HVS] = 0;
		KlClose[KLP_GLV_HVS] = 10;

		// Устанавливаем ШИМ отбора СР
		UstPower = PowerRect;
		// Подчиненные контроллеры переводим в ректификацию
		digitalWrite(PIN_SLAVE_0, 1);
		digitalWrite(PIN_SLAVE_1, 1);
		digitalWrite(PIN_SLAVE_2, 0);
		digitalWrite(PIN_SLAVE_3, 0);

		ProcChimSR = GetCHIMOtbor();  // Реализуется отбор по-шпоре, что в функции прописано то и будет возвращено.

		KlOpen[KLP_SR] = ((timeChimRectOtbSR / 10)*ProcChimSR) / 10;
		KlClose[KLP_SR] = timeChimRectOtbSR - KlOpen[KLP_SR];

		if (temps[TEMP_RK20] >= tStabSR + tDeltaRect) // Если текущая температура превысила базовую 
		{
			//        //Если температура превысилась менее, чем за одну минуту
			//        if (Seconds-SecTempPrev<60)
			//          {
			// произошел стоп - если значение количества температур в кубе меньше нуля, тогда запомним температуру в кубе за вычетом 0.1 градуса и процент ШИМ, при котором это произошло.
			if (CntCHIM < 0)
			{
				// Запоминаем температуру, когда произошел стоп за вычетом 0.1 градуса.
				tempK[-CntCHIM] = temps[TEMP_KUB] - 1;
				CHIM[-CntCHIM] = ProcChimSR;
				if (-CntCHIM < COUNT_CHIM - 1) CntCHIM--;
			}

			if (DecrementCHIM >= 0) ProcChimSR = ProcChimSR - DecrementCHIM;  // Тогда уменьшаем  ШИМ указанное число процентов в абсолютном выражении
			else
			{
				V3 = ((int)ProcChimSR* (int)-DecrementCHIM) / 100;
				// Процентное отношение может быть очень мало, поэтому если получилось нулевое значение, то вычтем единицу.
				if (V3 <= 0) V3 = 1;
				ProcChimSR = ProcChimSR - (char)V3; // Тогда увеличиваем ШИМ на число процентов в относительном выражении
			}

			if (ProcChimSR < minProcChimOtbSR) ProcChimSR = minProcChimOtbSR;

			StateMachine = 5;
			time1 = TimeRestabKolonna; // Взводим таймер для возможной рестабилизации колонны
			if (BeepStateProcess) my_beep(BEEP_LONG);
		}
		else // Если температура не выросла более, чем за 10 минут, прибавим ШИМ на 5%
		{
			if (Seconds - SecTempPrev > TimeAutoIncCHIM) // Если не стабилизировалось более, чем за 10 минут, тогда прибавляем ШИМ на 5%
			{

				// Шим прибавляем только если не дошли до минимального шима, если дошли, то считаем, что хватит играть ШИМом
				if (ProcChimSR > minProcChimOtbSR)
				{
					if (IncrementCHIM >= 0)   ProcChimSR = ProcChimSR + IncrementCHIM; // Тогда увеличиваем ШИМ указанное число процентов в абсолютном выражении
					else    ProcChimSR = ProcChimSR + ((int)ProcChimSR* (int)-IncrementCHIM) / 100; // Тогда увеличиваем ШИМ на число процентов в относительном выражении

					if (ProcChimSR > 95) ProcChimSR = 95;
				}
				SecTempPrev = Seconds;// Запомним время, когда стабилизировалась температура
			}
		}

		// Если температура в кубе превысила температуру при которой надо отбирать СР
		if (temps[TEMP_KUB] >= tEndRectOtbSR)
		{
			StateMachine = 7;
			KlOpen[KLP_SR] = 0;// Отключаем клапана отбора СР
			KlClose[KLP_SR] = 10;
			if (BeepStateProcess) my_beep(BEEP_LONG);
		}
		else
			break;
	case 7: // Отбор Хвостов
		UstPower = PowerRect;
		// Подчиненные контроллеры переводим в ректификацию
		digitalWrite(PIN_SLAVE_0, 1);
		digitalWrite(PIN_SLAVE_1, 1);
		digitalWrite(PIN_SLAVE_2, 0);
		digitalWrite(PIN_SLAVE_3, 0);

		KlOpen[KLP_GLV_HVS] = ((timeChimRectOtbGlv / 10) * 90) / 10;
		KlClose[KLP_GLV_HVS] = timeChimRectOtbGlv - KlOpen[KLP_GLV_HVS];
		if (temps[TEMP_KUB] >= tEndRect)
		{
			StateMachine = 8;
			SecTempPrev = Seconds;// Запомним время, когда закончилась ректификация
			if (BeepStateProcess) my_beep(BEEP_LONG);
		}
		else
			break;
	case 8:// Ждем три минуты для окончания подачи воды
		UstPower = 0;
		// Подчиненные контроллеры отключаем
		digitalWrite(PIN_SLAVE_0, 0);
		digitalWrite(PIN_SLAVE_1, 0);
		digitalWrite(PIN_SLAVE_2, 0);
		digitalWrite(PIN_SLAVE_3, 0);

		KlOpen[KLP_GLV_HVS] = 0;  // Отключаем клапана отбора хвостов
		KlClose[KLP_GLV_HVS] = 10;

		if (Seconds - SecTempPrev > 180)
		{
			// Переводим автомат в конечное состояние
			StateMachine = 100;
			SecondsEnd = Seconds;
			if (BeepStateProcess) my_beep(BEEP_LONG);
		}
		break;
	case 9:// Ожидание, пока датчик уровня отменяет сработку.
		V3 = U_UROVEN;
		if (V3 < UROVEN_ALARM)
		{
			Count_Provodimost++;
#ifdef TEST
			sprintf(my_tx_buffer,"ALARM VOZVRAT U_UROVEN=%i cnt=%i",U_UROVEN,Count_Provodimost);
			Serial1.println(my_tx_buffer);
#endif      
			// По прошествии минуты устанавливаем флаг сработки.
			if (Count_Provodimost > 2)
			{
				flAlarmUroven = 0;
				StateMachine = OldStateMachine;
				Count_Provodimost = 0;
			}
		}
		else
		{
			Count_Provodimost = 0;
		}
		break;

	case 101: // Превышение температуры в ТСА!!!
		my_beep(5 * BEEP_LONG);
	case 100:// Конечное состояние автомата

		// Отключаем на всякий случай все!
		if (FlToGSM && lastSMSState != StateMachine) StateToSMS();

		if (StateMachine == 100 && BeepEndProcess) my_beep(BEEP_LONG);

		UstPower = 0;
		CloseAllKLP();
		//    digitalWrite(PIN_REG_ON,LOW);
		digitalWrite(PIN_RZG_ON, !RELAY_HIGH);
		digitalWrite(PIN_ALL_OFF, ALL_OFF_HIGH);
		flAllOff = 1;
		// Отключаем подчиненные контроллеры
		digitalWrite(PIN_SLAVE_0, 0);
		digitalWrite(PIN_SLAVE_1, 0);
		digitalWrite(PIN_SLAVE_2, 0);
		digitalWrite(PIN_SLAVE_3, 0);

		break;
	}

}

void ProcessNDRF()
{

	//#define KLP_NPG  0      // Номер клапана для управления НПГ (при дистилляции) 
	//#define KLP_VODA 1      // Номер клапана для управления общей подачей воды в систему
	//#define KLP_DEFL 2      // Номер клапана для подачи воды в дейфлегматор
	//#define KLP_GLV_HVS  3       // Номер клапана отбора головных и хвостовых фракций
	//#define KLP_SR   4      // Номер клапана отбора ректификата
	//#define TEMP_KUB  0      // Номер датчика  термометра в кубе
	//#define TEMP_RK20 1      // Номер датчика термометра в РК 20 см от насадки
	//#define TEMP_TSA  2      // Номер термометра в трубке связи с атмосферой
	static char Count_Provodimost = 0; // Количество срабатываний датчика проводимости для окончания отбора голов.
	static char OldStateMachine = 0; // Количество срабатываний датчика проводимости для окончания отбора голов.
	int V3; // Текущий уровень проводимости;

	if (flAlarmUroven && StateMachine < 8)
	{ // Переводим автомат в стадию завершения 
		if (USE_ALARM_UROVEN == 1)
		{
			StateMachine = 8; // Переводим в режим окончания
			SecTempPrev = Seconds;// Запомним время, когда закончилась ректификация
			if (BeepStateProcess) my_beep(BEEP_LONG);
		}
		else
		{
			OldStateMachine = StateMachine;
			StateMachine = 9;  // Переводим в режим ожидания
			if (BeepStateProcess) my_beep(BEEP_LONG);
			Count_Provodimost = 0;
			KlOpen[KLP_GLV_HVS] = 0;
			KlClose[KLP_GLV_HVS] = 100;
			KlOpen[KLP_SR] = 0;
			KlClose[KLP_SR] = 100;
		}
	}

	// Проверяем температуру в ТСА
	if (temps[TEMP_TSA] >= MAX_TEMP_TSA)
	{
		StateMachine = 101; // Переводим автомат в состояние аварии по ТСА.
	}


	switch (StateMachine)
	{
	case 0: // Процесс не запущен
		break;
	case 1: // Начало процесса
		PrepareProcess();
		KlReg[KLP_GLV_HVS] = PEREGREV_ON;
		KlReg[KLP_SR] = PEREGREV_ON;

		//          if (FlToGSM && lastSMSState!=StateMachine) StateToSMS();
		lastSMSState = 0;

		KlOpen[KLP_VODA] = PER_KLP_OPEN;
		KlClose[KLP_VODA] = PER_KLP_CLOSE;
		//    digitalWrite(PIN_REG_ON,HIGH);
		digitalWrite(PIN_RZG_ON, RELAY_HIGH);
		digitalWrite(PIN_ALL_OFF, !ALL_OFF_HIGH);
		flAllOff = 0;
		StateMachine = 2;
		if (BeepStateProcess) my_beep(BEEP_LONG);
		Count_Provodimost = 0;
	case 2: // Разгон
		UstPower = Power; // Устанавливаем максимальную мощность для разгона

		if (temps[TEMP_KUB] < tEndRectRazgon) break;

		// Подаем питание на клапан дефлегматора
		KlOpen[KLP_DEFL] = PER_KLP_OPEN;
		KlClose[KLP_DEFL] = PER_KLP_CLOSE;
		TempPrev = temps[TEMP_RK20];
		SecTempPrev = Seconds; // Запоминаем дату последнего изменения температуры
		SecOstatok = 1800; // Стаблилизация колонный по-умолчанию полчаса
		StateMachine = 3;
		digitalWrite(PIN_RZG_ON, !RELAY_HIGH);
		if (BeepStateProcess) my_beep(BEEP_LONG);

	case 3:// Стабилизация температуры (строго по времени)
		UstPower = PowerRect;
		if (temps[TEMP_RK20] > 500) // Если температура больше 70 градусов (вдруг куб прогрелся, а колонна еще нет, нелогично, конечно, но на всякий случай учтем)
		{
			// Стабилизация строго по температуре 
			SecOstatok = SecOstatok - (Seconds - SecTempPrev);
			SecTempPrev = Seconds;
			if (SecOstatok <= 0)
			{
				StateMachine = 4;
				SecTempPrev = Seconds;
			}
			else
				break;
		}
		else
		{
			SecTempPrev = Seconds; // Запоминаем дату последнего изменения температуры
			break;
		}

	case 4: // Отбор голов
		UstPower = PowerRect;
		//unsigned int timeChimRectOtbGlv=2000;  // Шим отбора голов (в полупериодах сетевого напряжения в данном случае это около 20 секунд)
		//unsigned char ProcChimOtbGlv=5;  // Процент ШИМ отбора голов (в данном случае это 5 процентов)
		// Устанавливаем клапан отбора хвостов и голов в соответвии с установленнным ШИМ
		//int tEndRectOtbGlv=854;     // Температура окончания отбора голов 85.4 С
		KlOpen[KLP_GLV_HVS] = ((timeChimRectOtbGlv / 10)*ProcChimOtbGlv) / 10;
		KlClose[KLP_GLV_HVS] = timeChimRectOtbGlv - KlOpen[KLP_GLV_HVS];
		tStabSR = temps[TEMP_RK20];// Это температура, относительно которой будем стабилизировать отбор


		if (UrovenProvodimostSR == 0) // Если проводимость спирта не используется, головы отбираем по температуре
		{
			if (temps[TEMP_KUB] < tEndRectOtbGlv)
			{  // Пока температура в кубе не выросла выше окончания отбора голов, продолжаем это состояни
				break;
			}
		}
		else
		{

			if (UrovenProvodimostSR > 0) // Если проводимость больше нуля, используем проводимость в том или ином виде
			{
				V3 = U_GLV;
				// Если проводимость менее заданного уровня, и проводимость вообще сущетвует, то увеличиваем счетчик срабатываний
				// или ести проводимость больше уровня тревоги и установлен признак отбирать головы по уровню в приемной емкости.

				if ((V3 < UrovenProvodimostSR && V3 >= 2 && UrovenProvodimostSR >= 5) || (V3 >= UROVEN_ALARM && UrovenProvodimostSR <= 2))
					Count_Provodimost++;
				else
					Count_Provodimost = 0;

				// Если счетчик срабатываний не превысил максимальное число раз, тогда продолжаем процесс отбора голов.
				if (Count_Provodimost < MAX_COUNT_PROVODIMOST_SR) break;
			}
			else // Если уровень проводимости SR меньше нуля, тогда это означает, что отбор голов производится по времени (в десятках минут).
			{
				// Анализируем, сколько минут прошло с начала отбора голов.
				SecOstatok = -((Seconds - SecTempPrev) / 600 + UrovenProvodimostSR);
				if (SecOstatok > 0) break;
			}
		}

		// Если температура превысила указанный рубеж, то переходим в состояние отбора спирта-ректификата.
		// Клапан отбора голов и хвостов отключаем
		tStabSR = temps[TEMP_RK20];// Это температура, относительно которой будем стабилизировать отбор
		KlOpen[KLP_GLV_HVS] = 0;
		KlClose[KLP_GLV_HVS] = 10;
		ProcChimSR = begProcChimOtbSR;
		StateMachine = 5;
		if (BeepStateProcess) my_beep(BEEP_LONG);

	case 5: // Ожидание, пока температура не вернется к состоянию стабилизации
		// Это для отладки страт-стопа, на самом деле температура 28,5 градуса в этом режиме в колонне быть не может
		if (tStabSR == 0) tStabSR = 285;

		KlOpen[KLP_SR] = 0;
		KlClose[KLP_SR] = 10;
		if (temps[TEMP_KUB] >= tEndRectOtbSR)
		{
			StateMachine = 7;
			if (BeepStateProcess) my_beep(BEEP_LONG);
			break;
		}

		if (temps[TEMP_RK20] > tStabSR)
		{
			break;
		}
		SecTempPrev = Seconds;// Запомним время, когда стабилизировалась температура
		StateMachine = 6;
		if (BeepStateProcess) my_beep(BEEP_LONG);
	case 6: // Отбор СР
		//unsigned int timeChimRectOtbSR=1000;  // Шим отбора СР (в полупериодах сетевого напряжения в данном случае это около 10 секунд)
		//unsigned char tDeltaRect=10;  // Дельта ректификации (в десятых градуса Цельсия) в данном случае - это 10 десятых, то есть 1 градус Цельсия
		//unsigned int tEndRectOtbSR=965;  // Температура окончания отбора спирта-ректификата и начала отбора хвостов (в данном случе 96.5 С)
		// Устанавливаем ШИМ отбора СР
		UstPower = PowerRect;
		KlOpen[KLP_SR] = ((timeChimRectOtbSR / 10)*ProcChimSR) / 10;
		KlClose[KLP_SR] = timeChimRectOtbSR - KlOpen[KLP_SR];

		if (temps[TEMP_RK20] >= tStabSR + tDeltaRect) // Если текущая температура превысила базовую, тогда останавливаем отбор
		{
			StateMachine = 5;
			if (BeepStateProcess) my_beep(BEEP_LONG);
		}

		// Если температура в кубе превысила температуру при которой надо отбирать СР
		if (temps[TEMP_KUB] >= tEndRectOtbSR)
		{
			StateMachine = 7;
			KlOpen[KLP_SR] = 0;// Отключаем клапана отбора СР
			KlClose[KLP_SR] = 10;
			if (BeepStateProcess) my_beep(BEEP_LONG);
		}
		else
			break;
	case 7: // Отбор Хвостов
		UstPower = PowerRect;
		KlOpen[KLP_GLV_HVS] = ((timeChimRectOtbGlv / 10) * 90) / 10;
		KlClose[KLP_GLV_HVS] = timeChimRectOtbGlv - KlOpen[KLP_GLV_HVS];
		if (temps[TEMP_KUB] >= tEndRect)
		{
			StateMachine = 8;
			SecTempPrev = Seconds;// Запомним время, когда закончилась ректификация
			if (BeepStateProcess) my_beep(BEEP_LONG);
		}
		else
			break;
	case 8:// Ждем три минуты для окончания подачи воды
		UstPower = 0;
		KlOpen[KLP_GLV_HVS] = 0;  // Отключаем клапана отбора хвостов
		KlClose[KLP_GLV_HVS] = 10;

		if (Seconds - SecTempPrev > 180)
		{
			// Переводим автомат в конечное состояние
			StateMachine = 100;
			SecondsEnd = Seconds;
			if (BeepStateProcess) my_beep(BEEP_LONG);
		}
		break;
		V3 = U_UROVEN;
		if (V3 < UROVEN_ALARM)
		{
			Count_Provodimost++;
#ifdef TEST
			sprintf(my_tx_buffer,"ALARM VOZVRAT U_UROVEN=%i cnt=%i",U_UROVEN,Count_Provodimost);
			Serial1.println(my_tx_buffer);
#endif      
			// По прошествии минуты устанавливаем флаг сработки.
			if (Count_Provodimost > 2)
			{
				flAlarmUroven = 0;
				StateMachine = OldStateMachine;
				Count_Provodimost = 0;
			}
		}
		else
		{
			Count_Provodimost = 0;
		}
		break;
	case 101: // Превышение температуры в ТСА!!!
		my_beep(5 * BEEP_LONG);
	case 100:// Конечное состояние автомата

		// Отключаем на всякий случай все!
		if (FlToGSM && lastSMSState != StateMachine) StateToSMS();

		if (StateMachine == 100 && BeepEndProcess) my_beep(BEEP_LONG);

		UstPower = 0;
		CloseAllKLP();
		//    digitalWrite(PIN_REG_ON,LOW);
		digitalWrite(PIN_RZG_ON, !RELAY_HIGH);
		digitalWrite(PIN_ALL_OFF, ALL_OFF_HIGH);
		flAllOff = 1;

		break;
	}

}

void ProcessNBK()
{

	//#define KLP_NPG  0      // Номер клапана для управления НПГ (при дистилляции) 
	//#define KLP_VODA 1      // Номер клапана для управления общей подачей воды в систему
	//#define KLP_DEFL 2      // Номер клапана для подачи воды в дейфлегматор
	//#define KLP_GLV_HVS  3       // Номер клапана отбора головных и хвостовых фракций
	//#define KLP_SR   4      // Номер клапана отбора ректификата
	//#define TEMP_KUB  0      // Номер датчика  термометра в кубе
	//#define TEMP_RK20 1      // Номер датчика термометра в РК 20 см от насадки
	//#define TEMP_TSA  2      // Номер термометра в трубке связи с атмосферой
	if (flAlarmUroven && StateMachine < 100)
	{ // Переводим автомат в стадию завершения 
		StateMachine = 100;
	}


	switch (StateMachine)
	{
	case 0: // Процесс не запущен
		break;
	case 1: // Начало процесса
		PrepareProcess();
		lastSMSState = 0;
		KlOpen[KLP_VODA] = PER_KLP_OPEN;
		KlClose[KLP_VODA] = PER_KLP_CLOSE;
		StateMachine = 2;
		if (BeepStateProcess) my_beep(BEEP_LONG);
	case 2:
		UstPower = Power;
		if (temps[TEMP_DEFL] < TempDeflBegDistil  && ds1820_devices>1) break;
		KlOpen[KLP_HLD] = PER_KLP_OPEN;
		KlClose[KLP_HLD] = PER_KLP_CLOSE;
		StateMachine = 3;
		if (BeepStateProcess) my_beep(BEEP_LONG);
	case 3:
		SpeedNBK = 0;
		UstPower = PowerNBK;
		time1 = 20 * 60; // Задаем время 20 минут с начала старта
		my_beep(BEEP_LONG * 3);
		break;
	case 4:
		UstPower = PowerNBK;
		SpeedNBK = SpeedNBKDst;
		timeNBK = 20;
		if (temps[TEMP_DEFL] >= 980 && time1 <= 0)
		{
			//Если температура превысила максимальную и с момента старта прошло более 20 минут, то считаем, что произошла авария - заклинил насос или кончилась брага.
			// Ждем 5 минут и завершаем процесс.
			time2 = 5 * 60;
			StateMachine = 5;
			if (BeepStateProcess) my_beep(BEEP_LONG);
		}
		break;
	case 5:
		SpeedNBK = SpeedNBKDst;
		timeNBK = 20;
		if (temps[TEMP_DEFL] < 970)
		{
			StateMachine = 4;
		}
		my_beep(BEEP_LONG * 5);
		if (time2 <= 0)
		{
			StateMachine = 100;
		}
		break;
	case 101: // Превышение температуры в ТСА!!!
		break;
		my_beep(5 * BEEP_LONG);
	case 100:// Конечное состояние автомата
		SpeedNBK = 0;
		timeNBK = 0;
		if (StateMachine == 100 && BeepEndProcess) my_beep(BEEP_LONG);
		UstPower = 0;
		CloseAllKLP();
		//    digitalWrite(PIN_REG_ON,LOW);
		digitalWrite(PIN_RZG_ON, !RELAY_HIGH);
		digitalWrite(PIN_ALL_OFF, ALL_OFF_HIGH);
		flAllOff = 1;
		if (FlToGSM && lastSMSState != StateMachine) StateToSMS();
		break;
	}

}

void ProcessSimpleDistill()
{
	int TekTemp;

	if (flAlarmUroven && StateMachine < 4)
	{ // Переводим автомат в стадию завершения 
		StateMachine = 4;
		SecondsEnd = 2 * 60;// Через две минуты отключим воду
		SecTempPrev = Seconds;
		if (BeepStateProcess) my_beep(BEEP_LONG);
	}

	// Проверяем температуру в ТСА
	if (temps[TEMP_TSA] >= MAX_TEMP_TSA)
	{
		StateMachine = 101; // Переводим автомат в состояние аварии по ТСА.
		UstPower = 0;
	}


	switch (StateMachine)
	{
	case 0: // Процесс не запущен
		break;
	case 1: // Начало процесса
		PrepareProcess();
		//          if (FlToGSM && lastSMSState!=StateMachine) StateToSMS();
		lastSMSState = 0;

		KlOpen[KLP_VODA] = PER_KLP_OPEN;
		KlClose[KLP_VODA] = PER_KLP_CLOSE;
		StateMachine = 2;
		if (BeepStateProcess) my_beep(BEEP_LONG);
		//    digitalWrite(PIN_REG_ON,HIGH);
		digitalWrite(PIN_RZG_ON, RELAY_HIGH);
		digitalWrite(PIN_ALL_OFF, !ALL_OFF_HIGH);
		flAllOff = 0;

	case 2: // Ожидание, пока прогреется термометр в дефлегматоре

		UstPower = Power; // Устанавливаем максимальную мощность для разгона
		// Подчиненные переводим в разгон
		digitalWrite(PIN_SLAVE_0, 1);
		digitalWrite(PIN_SLAVE_1, 0);
		digitalWrite(PIN_SLAVE_2, 0);
		digitalWrite(PIN_SLAVE_3, 0);

		// Если температура в дефлегматоре меньше 70 градусов и датчик дефлегматора в принципе подключен, тогда ждем, пока
		// дефлегматор прогреется, чтобы запустить воду в холодильник (это для некоторой экономии воды)
		if (temps[TEMP_DEFL] < TempDeflBegDistil && ds1820_devices>1) break;

		// Подаем питание на клапан подачи воды холодильника
		// для этого синхронизируем его с клапаном общей подачи воды (возможно, при этом будет меньше гидроударов, хотя я их и так не наблюдаю)
		flSyncKLP = true;
		KlOpen[KLP_HLD] = KlOpen[KLP_VODA];
		KlClose[KLP_HLD] = KlClose[KLP_VODA];
		KlState[KLP_HLD] = KlState[KLP_VODA];
		KlCount[KLP_HLD] = KlCount[KLP_VODA];
		flSyncKLP = false;
		StateMachine = 3;
		if (BeepStateProcess) my_beep(BEEP_LONG);
		digitalWrite(PIN_RZG_ON, !RELAY_HIGH);

	case 3:// Ждем, пока температура в кубе не превысит установленную
		UstPower = PowerDistil; // Устанавливаем максимальную мощность для разгона
		digitalWrite(PIN_SLAVE_0, 0);
		digitalWrite(PIN_SLAVE_1, 0);
		digitalWrite(PIN_SLAVE_2, 1); // Переводим подчиненный в режим дистилляции
		digitalWrite(PIN_SLAVE_3, 0);

		if (IspReg == 104) TekTemp = Temp1P; //Текущее состояние - первый недробный перегон
		if (IspReg == 106) TekTemp = Temp2P; //Текущее состояние - второй дробный 
		if (IspReg == 107) TekTemp = Temp3P; //Текущее состояние - третий дробный

		if (temps[TEMP_KUB] >= TekTemp)
		{
			StateMachine = 4;
			SecondsEnd = 2 * 60;// Через две минуты отключим воду
			SecTempPrev = Seconds;
			if (BeepStateProcess) my_beep(BEEP_LONG);
		}
		else
			break;
	case 4:// Ждем минуту для окончания подачи воды
		UstPower = 0;
		// Отключаем подчиненные
		digitalWrite(PIN_SLAVE_0, 0);
		digitalWrite(PIN_SLAVE_1, 0);
		digitalWrite(PIN_SLAVE_2, 0);
		digitalWrite(PIN_SLAVE_3, 0);
		SecondsEnd = SecondsEnd - (Seconds - SecTempPrev);
		SecTempPrev = Seconds;

		if (SecondsEnd <= 0)
		{
			// Переводим автомат в конечное состояние
			StateMachine = 100;
			SecondsEnd = Seconds;
			if (BeepStateProcess) my_beep(BEEP_LONG);
		}
		break;
	case 101: // Превышение температуры в ТСА!!!
		my_beep(5 * BEEP_LONG);
	case 100:// Конечное состояние автомата
		// Отключаем на всякий случай все!
		if (FlToGSM && lastSMSState != StateMachine) StateToSMS();
		if (BeepEndProcess) my_beep(BEEP_LONG);
		UstPower = 0;
		// Отключаем подчиненные
		digitalWrite(PIN_SLAVE_0, 0);
		digitalWrite(PIN_SLAVE_1, 0);
		digitalWrite(PIN_SLAVE_2, 0);
		digitalWrite(PIN_SLAVE_3, 0);
		CloseAllKLP();
		//    digitalWrite(PIN_REG_ON,LOW);
		digitalWrite(PIN_RZG_ON, !RELAY_HIGH);
		digitalWrite(PIN_ALL_OFF, ALL_OFF_HIGH);
		flAllOff = 1;

		break;
	}

}

void CloseAllKLP()
{
	char i;
	// Все клапана зануляем.
	for (i = 0; i < MAX_KLP; i++)
	{
		KlOpen[i] = 0;
		KlClose[i] = 10;
		KlState[i] = 0;          // Начальное состояние - клапан закрыт, счетчик 0
		KlCount[i] = 0;
		KlReg[i] = PEREGREV_ON;
	}
}

void PrepareProcess()
{
	char i;
	// Все клапана зануляем.
	for (i = 0; i < MAX_DS1820; i++)
	{
		Maxtemps[i] = 0;
	}
	timeMIXER = 0;
	timeNBK = 0;
	time1 = 0;
	time2 = 0;
	time3 = 0;
	CloseAllKLP();
}

// Процесс отбора голов (без дефлегматора)
void ProcessSimpleGlv()
{

	if (flAlarmUroven && StateMachine < 5)
	{ // Переводим автомат в стадию завершения 
		StateMachine = 5;
		SecondsEnd = 60;// Через одну минуту отключим воду
		SecTempPrev = Seconds;
		if (BeepStateProcess) my_beep(BEEP_LONG);
	}

	// Проверяем температуру в ТСА
	if (temps[TEMP_TSA] >= MAX_TEMP_TSA)
	{
		StateMachine = 101; // Переводим автомат в состояние аварии по ТСА.
		UstPower = 0;
	}

	switch (StateMachine)
	{
	case 0: // Процесс не запущен
		break;
	case 1: // Начало процесса
		PrepareProcess();
		//         if (FlToGSM && lastSMSState!=StateMachine) StateToSMS();
		lastSMSState = 0;

		KlOpen[KLP_VODA] = PER_KLP_OPEN;
		KlClose[KLP_VODA] = PER_KLP_CLOSE;
		StateMachine = 2;
		//    digitalWrite(PIN_REG_ON,HIGH);
		digitalWrite(PIN_RZG_ON, RELAY_HIGH);
		digitalWrite(PIN_ALL_OFF, !ALL_OFF_HIGH);
		flAllOff = 0;

		if (BeepStateProcess) my_beep(BEEP_LONG);
	case 2: // Ожидание, пока прогреется термометр в дефлегматоре

		UstPower = Power; // Устанавливаем максимальную мощность для разгона
		// Подчиненные в разгон
		digitalWrite(PIN_SLAVE_0, 1);
		digitalWrite(PIN_SLAVE_1, 0);
		digitalWrite(PIN_SLAVE_2, 0);
		digitalWrite(PIN_SLAVE_3, 0);


		// Если температура в дефлегматоре меньше 70 градусов и датчик дефлегматора в принципе подключен, тогда ждем, пока
		// дефлегматор прогреется, чтобы запустить воду в холодильник (это для некоторой экономии воды)
		if (temps[TEMP_DEFL] < TempDeflBegDistil && ds1820_devices>1) break;

		// Подаем питание на клапан подачи воды холодильника
		StateMachine = 3;
		if (BeepStateProcess) my_beep(BEEP_LONG);
	case 3:
		// Ждем, пока температура в кубе не достигнет температуры начала дистилляции (если есть датчик дефлегматора, тогда этот пункт сразу
		// проскочится, поскольку темперетура в кубе не может быть меньше, чем температура в дефлегматоре
		if (temps[TEMP_KUB] < TempDeflBegDistil) break;

		// Подаем питание на клапан подачи воды холодильника
		flSyncKLP = true;
		KlOpen[KLP_HLD] = KlOpen[KLP_VODA];
		KlClose[KLP_HLD] = KlClose[KLP_VODA];
		KlState[KLP_HLD] = KlState[KLP_VODA];
		KlCount[KLP_HLD] = KlCount[KLP_VODA];
		flSyncKLP = false;

		StateMachine = 4;
		if (BeepStateProcess) my_beep(BEEP_LONG);
		digitalWrite(PIN_RZG_ON, !RELAY_HIGH);
	case 4:// Работа в режиме отбра голов идет исключетельно по наполнению приемной емкости, но все-таки температуру
		// на всякий случай анализируем, ведь температура в кубе при отборе голов, в любом случае не может быть больше, чем температура окончания
		// третьей дробной перегонки

		UstPower = PowerGlvDistil; // Устанавливаем мощность отбора голов.
		// Клапан отбора голов устанавливаем, поскольку по совместительству этот режим может использоваться и для эпюрации
		// Устанавливаем клапан отбора хвостов и голов в соответвии с установленнным ШИМ
		//int tEndRectOtbGlv=854;     // Температура окончания отбора голов 85.4 С
		KlOpen[KLP_GLV_HVS] = ((timeChimRectOtbGlv / 10)*ProcChimOtbGlv) / 10;
		KlClose[KLP_GLV_HVS] = timeChimRectOtbGlv - KlOpen[KLP_GLV_HVS];

		// Подчиненные в режим отбора голов
		digitalWrite(PIN_SLAVE_0, 0);
		digitalWrite(PIN_SLAVE_1, 1);
		digitalWrite(PIN_SLAVE_2, 0);
		digitalWrite(PIN_SLAVE_3, 0);

		if (temps[TEMP_KUB] >= Temp3P)
		{
			StateMachine = 5;
			SecondsEnd = 1 * 60;// Через две минуты отключим воду
			SecTempPrev = Seconds;
			if (BeepStateProcess) my_beep(BEEP_LONG);

		}
		else
			break;
	case 5:// Ждем минуту для окончания подачи воды
		UstPower = 0;
		// Подчиненные отключаем
		digitalWrite(PIN_SLAVE_0, 0);
		digitalWrite(PIN_SLAVE_1, 0);
		digitalWrite(PIN_SLAVE_2, 0);
		digitalWrite(PIN_SLAVE_3, 0);

		SecondsEnd = SecondsEnd - (Seconds - SecTempPrev);
		SecTempPrev = Seconds;

		if (SecondsEnd <= 0)
		{
			// Переводим автомат в конечное состояние
			StateMachine = 100;
			SecondsEnd = Seconds;
			if (BeepStateProcess) my_beep(BEEP_LONG);
		}
		break;
	case 101:
	case 100:// Конечное состояние автомата
		// Отключаем на всякий случай все!
		if (FlToGSM && lastSMSState != StateMachine) StateToSMS();
		if (BeepEndProcess) my_beep(BEEP_LONG);
		UstPower = 0;
		// Подчиненные отключаем
		digitalWrite(PIN_SLAVE_0, 0);
		digitalWrite(PIN_SLAVE_1, 0);
		digitalWrite(PIN_SLAVE_2, 0);
		digitalWrite(PIN_SLAVE_3, 0);

		CloseAllKLP();
		//    digitalWrite(PIN_REG_ON,LOW);
		digitalWrite(PIN_RZG_ON, !RELAY_HIGH);
		digitalWrite(PIN_ALL_OFF, ALL_OFF_HIGH);
		flAllOff = 1;

		break;
	}
}


// Процесс дистилляции с подключаемым дефлегматором
// Процесс поддерживат температуру в дефлегматоре не более заданной + дельта и не менее заданной - дельта
void ProcessDistilDefl()
{

	// Если достигнут уровень в приемной емкости или температуре в кубе превысыла допустимую температуру для этого режима

	if ((flAlarmUroven || temps[TEMP_KUB] >= tEndDistDefl || deltaPower >= Power) && StateMachine < 7)
	{ // Переводим автомат в стадию завершения 
		StateMachine = 7;
		SecondsEnd = 2 * 60;// Через одну минуту отключим воду
		SecTempPrev = Seconds;
		if (BeepStateProcess) my_beep(BEEP_LONG);
	}
	// Проверяем температуру в ТСА
	if (temps[TEMP_TSA] >= MAX_TEMP_TSA)
	{
		StateMachine = 101; // Переводим автомат в состояние аварии по ТСА.
		UstPower = 0;
	}

	switch (StateMachine)
	{
	case 0: // Процесс не запущен
		break;
	case 1: // Начало процесса
		PrepareProcess();
		//          if (FlToGSM && lastSMSState!=StateMachine) StateToSMS();
		lastSMSState = 0;
		KlOpen[KLP_VODA] = PER_KLP_OPEN;
		KlClose[KLP_VODA] = PER_KLP_CLOSE;
		StateMachine = 2;//Этот процесс пока заблокирован, сразу идем на окончание.
		//    digitalWrite(PIN_REG_ON,HIGH);
		digitalWrite(PIN_RZG_ON, RELAY_HIGH);
		digitalWrite(PIN_ALL_OFF, !ALL_OFF_HIGH);
		flAllOff = 0;
		if (BeepStateProcess) my_beep(BEEP_LONG);
		deltaPower = 0;
	case 2: // Ожидание, пока прогреется термометр в дефлегматоре

		UstPower = Power; // Устанавливаем максимальную мощность для разгона

		// Если температура в дефлегматоре меньше 70 градусов и датчик дефлегматора в принципе подключен, тогда ждем, пока
		// дефлегматор прогреется, чтобы запустить воду в холодильник (это для некоторой экономии воды)
		if (temps[TEMP_DEFL] < TempDeflBegDistil && ds1820_devices>1) break;

		// Подаем питание на клапан подачи воды холодильника
		StateMachine = 3;
		if (BeepStateProcess) my_beep(BEEP_LONG);

	case 3:
		// Ждем, пока температура в кубе не достигнет температуры начала дистилляции (если есть датчик дефлегматора, тогда этот пункт сразу
		// проскочится, поскольку темперетура в кубе не может быть меньше, чем температура в дефлегматоре
		if (temps[TEMP_KUB] < TempDeflBegDistil) break;
		// Подаем питание на клапан подачи воды холодильника

		// Подаем питание на клапан подачи воды холодильника
		// для этого синхронизируем его с клапаном общей подачи воды (возможно, при этом будет меньше гидроударов, хотя я их и так не наблюдаю)
		flSyncKLP = true;
		KlOpen[KLP_HLD] = KlOpen[KLP_VODA];
		KlClose[KLP_HLD] = KlClose[KLP_VODA];
		KlState[KLP_HLD] = KlState[KLP_VODA];
		KlCount[KLP_HLD] = KlCount[KLP_VODA];
		flSyncKLP = false;

		StateMachine = 4;
		time2 = 15 * 60; // Взводиим таймер на 15 минут   
		if (BeepStateProcess) my_beep(BEEP_LONG);
		digitalWrite(PIN_RZG_ON, !RELAY_HIGH);

	case 4: // Дефлегматор отключен.
		// Если более 10 минут не вышли за пределы температуры, тогда увеличиваем мощность.
		if (time2 == 0)
		{
			deltaPower = deltaPower - (int)(PowerDistil / 20);
			if (deltaPower < 0) deltaPower = 0;
			time2 = 10 * 60;
		}

		UstPower = PowerDistil - deltaPower; // Устанавливаем мощность дистилляции.

		if (temps[TEMP_DEFL] > TempDefl)
		{
			// Включаем дефлегматор и холодильник
			flSyncKLP = true;

			KlOpen[KLP_DEFL_D] = KlOpen[KLP_VODA];
			KlClose[KLP_DEFL_D] = KlClose[KLP_VODA];
			KlState[KLP_DEFL_D] = KlState[KLP_VODA];
			KlCount[KLP_DEFL_D] = KlCount[KLP_VODA];

			KlOpen[KLP_HLD] = KlOpen[KLP_VODA];
			KlClose[KLP_HLD] = KlClose[KLP_VODA];
			KlState[KLP_HLD] = KlState[KLP_VODA];
			KlCount[KLP_HLD] = KlCount[KLP_VODA];
			flSyncKLP = false;
			StateMachine = 5; // Переходим к этапу поддержания температуры путем частичной подачи воды в дефлегмато
			if (BeepStateProcess) my_beep(BEEP_LONG);
		}
		else
			break;

	case 5:// 50% воды из холодильника идет в дефлегматор.
		// Если более 10 минут не вышли за пределы температуры, тогда увеличиваем мощность.
		time2 = 10 * 60;
		if (time3 == 0)
		{
			deltaPower = deltaPower - (int)(PowerDistil / 30);
			if (deltaPower < 0) deltaPower = 0;
			time3 = 10 * 60;
		}
		UstPower = PowerDistil - deltaPower; // Устанавливаем мощность дистилляции.
		// Если температура превысила температуру, которую надо поддерживать в дефлегматоре+дельта, тогда переходим к режиму, когда
		// вся вода из холодильника идет через дефлегматор
		if (temps[TEMP_DEFL] > TempDefl + DeltaDefl)
		{
			// Отключаем прямой выход из холодильника
			KlOpen[KLP_HLD] = 0;
			KlClose[KLP_HLD] = 10;
			// Включаем дефлегматор
			flSyncKLP = true;
			KlOpen[KLP_DEFL_D] = KlOpen[KLP_VODA];
			KlClose[KLP_DEFL_D] = KlClose[KLP_VODA];
			KlState[KLP_DEFL_D] = KlState[KLP_VODA];
			KlCount[KLP_DEFL_D] = KlCount[KLP_VODA];
			flSyncKLP = false;

			StateMachine = 6; // Переходим к этапу поддержания температуры путем 100% направления воды в дефлегматор        
			time1 = 0;
			if (BeepStateProcess) my_beep(BEEP_LONG);
		}
		else
			if (temps[TEMP_DEFL] < TempDefl - DeltaDefl) // Если в результате работы с 50% дефлегматором, температура понизилась переходим в режим работы без дефлегматора
			{

				KlOpen[KLP_DEFL_D] = 0;
				KlClose[KLP_DEFL_D] = 10;

				flSyncKLP = true;
				KlOpen[KLP_HLD] = KlOpen[KLP_VODA];
				KlClose[KLP_HLD] = KlClose[KLP_VODA];
				KlState[KLP_HLD] = KlState[KLP_VODA];
				KlCount[KLP_HLD] = KlCount[KLP_VODA];
				flSyncKLP = false;
				StateMachine = 4; // Переходим к этапу без дефлегмации
				if (BeepStateProcess) my_beep(BEEP_LONG);
				break;
			}
			else
				break;

	case 6: // Вся вода из холодильника идет в дефлегматор.
		// Взводиим таймер на 10 минут
		time3 = 10 * 60;
		UstPower = PowerDistil - deltaPower; // Устанавливаем мощность дистилляции.
		// Если температура превысила требуемую + дельта более, чем на полдельта за три минуты, тогда уменьшааем мощность 
		if (temps[TEMP_DEFL] > TempDefl + DeltaDefl + DeltaDefl / 2)
		{
			if (time1 == 0)
			{
				deltaPower = deltaPower + (int)(PowerDistil / 10);
				time1 = 3 * 60;// Взводим таймер на три минуты.
			}
		}

		if (temps[TEMP_DEFL] < TempDefl) // Если в результате работы с 100% дефлегматором, температура понизилась ниже установленной температуры переходим в режим работы с 50% дефлегма
		{
			// Включаем прямой выход из холодильника.
			flSyncKLP = true;
			KlOpen[KLP_HLD] = KlOpen[KLP_VODA];
			KlClose[KLP_HLD] = KlClose[KLP_VODA];
			KlState[KLP_HLD] = KlState[KLP_VODA];
			KlCount[KLP_HLD] = KlCount[KLP_VODA];

			KlOpen[KLP_DEFL_D] = KlOpen[KLP_VODA];
			KlClose[KLP_DEFL_D] = KlClose[KLP_VODA];
			KlState[KLP_DEFL_D] = KlState[KLP_VODA];
			KlCount[KLP_DEFL_D] = KlCount[KLP_VODA];
			flSyncKLP = false;
			StateMachine = 5; // Переходим к этапу поддержания температуры 50% дефлегмацией
			time2 = 15 * 60; // Взводиим таймер на 15 минут   
			if (BeepStateProcess) my_beep(BEEP_LONG);
			break;
		}
		else
			break;

	case 7:// Ждем минуту для окончания подачи воды
		UstPower = 0;
		SecondsEnd = SecondsEnd - (Seconds - SecTempPrev);
		SecTempPrev = Seconds;

		if (SecondsEnd <= 0)
		{
			// Переводим автомат в конечное состояние
			StateMachine = 100;
			SecondsEnd = Seconds;
			if (BeepStateProcess) my_beep(BEEP_LONG);
		}
		break;
	case 100:// Конечное состояние автомата
		if (BeepEndProcess) my_beep(BEEP_LONG);
	case 101:
		// Отключаем на всякий случай все!
		if (FlToGSM && lastSMSState != StateMachine) StateToSMS();
		if (BeepEndProcess) my_beep(BEEP_LONG);
		UstPower = 0;
		CloseAllKLP();
		//    digitalWrite(PIN_REG_ON,LOW);
		digitalWrite(PIN_RZG_ON, !RELAY_HIGH);
		digitalWrite(PIN_ALL_OFF, ALL_OFF_HIGH);
		flAllOff = 1;

		break;
	}
}


void ProcessRazvarZerno()
{
	switch (StateMachine)
	{
	case 0: //Не запущено

		break;
	case 1: //Нагрев до температуры 50 градусов
		timeNBK = 0;
		SpeedNBK = 0;
		// Этот пункт пропускаем, потому что и так работает мешалка.
		//      digitalWrite(PIN_RZG_ON,!RELAY_HIGH);
		//  
		//      // Если необходимо отправлять состояние на сотовый и это состояние еще не отправлялось, тогда информируем о состоянии процесса
		//  //    if (FlToGSM && lastSMSState!=StateMachine) StateToSMS();
		lastSMSState = 0;
		//  
		//  
		//      if (temps[TEMP_RAZVAR]<500)
		//      {
		//        UstPower=Power;
		//        break;
		//      }
		TempHLDZatorBrog = 355;
		StateMachine = 2;
		//      if (BeepStateProcess) my_beep(BEEP_LONG);

	case 2: //Поддержание температуры 50 градусов, пока не произойдет ручной переход к следующему этапу.
		// Из этого режима можно выйти только вручную, нажав кнопку вверх или отладочной функцией одновременно нажав вверх и вниз.
		// Пищим, чтобы привлечь внимание
		//      if (BeepStateProcess) my_beep(BEEP_LONG);
		//      if (temps[TEMP_RAZVAR]<480)
		//      {
		//        UstPower=PowerRazvZerno;
		//      }
		//      if (temps[TEMP_RAZVAR]>=500)
		//      {
		//        UstPower=0;
		//      }
		//      break;
		StateMachine = 3;
		time1 = 0;
		timeMIXER = 0;
	case 3: //Нагрев до температуры 64 градуса
		if (temps[TEMP_RAZVAR] < TempZasypSolod)
		{
			// Работаем в следующем режиме - 2 минуты пауза, 2 минута работает миксер.
			if (time1 == 0)
			{
				time1 = 4 * 60;
				timeMIXER = 2 * 60;
			}

			UstPower = PowerVarkaZerno;
			break;
		}
		time1 = 0;
		timeMIXER = 0;
		StateMachine = 4;
		if (BeepStateProcess) my_beep(BEEP_LONG);
		SecTempPrev = Seconds;
		time2 = 15 * 60;  // Взводим таймер на 15 секунд паузы
		if (IspReg == 113)
		{
			// Если затор из муки и солода, переходим сразу к размешиванию и последующему осахариванию.
			time2 = 10 * 60; // Устанавливаем время на работу мешалки после засыпки солода - 10 минут
			time1 = 0;
			StateMachine = 9;
			break;
		}




	case 4: //Ожидание 15 минут, поддержка температуры
		timeNBK = 0;
		SpeedNBK = 0;

		// Работаем в следующем режиме - 2 минуты пауза, 1 минута работает миксер.
		if (time1 == 0)
		{
			time1 = 3 * 60;
			timeMIXER = 2 * 60;
		}

		if (temps[TEMP_RAZVAR] < TempZasypSolod - 20)
		{
			UstPower = PowerRazvZerno;
		}
		if (temps[TEMP_RAZVAR] >= TempZasypSolod)
		{
			UstPower = 0;
		}

		// Закончилось время паузы
		if (time2 == 0)
		{
			StateMachine = 5;
			if (BeepStateProcess) my_beep(BEEP_LONG);
		}
		else
			break;

	case 5:
		timeNBK = 0;
		SpeedNBK = 0;
		//  Нагрев до закипания закипание определяется по преввшениею температуры либо в заторнике, либо в верхней части заторника.
		//  Миксер Работаем в следующем режиме - 5 минут пауза, 1 минута работает миксер.
		if (time1 == 0)
		{
			time1 = 6 * 60;
			timeMIXER = 2 * 60;
		}

		UstPower = PowerVarkaZerno;

		if ((temps[TEMP_RAZVAR] >= TempKipenZator && ds1820_devices < 2) || temps[TEMP_DEFL] >= TempKipenZator) // Если температура затора, либо температура дефлегматора больше заданной
		{
			// Переходим к следующему этапу - варка 1 часа. 
			StateMachine = 6;
			time2 = 1 * 60 * 60; // Это 1.5 часа в секундах 
			if (BeepStateProcess) my_beep(BEEP_LONG);
		}
		else
			break;

	case 6: //Варка
		timeNBK = 0;
		SpeedNBK = 0;
		UstPower = PowerRazvZerno;
		//  Миксер Работаем в следующем режиме - 5 минут пауза, 1 минута работает миксер.
		if (time1 == 0)
		{
			time1 = 6 * 60;
			timeMIXER = 2 * 60;
		}

		if (time2 == 0)
		{
			StateMachine = 7;
			if (BeepStateProcess) my_beep(BEEP_LONG);
			time1 = 0;
		}
		else
			break;
	case 7: //охлаждение до температуры осахаривания.
		timeNBK = 0;
		SpeedNBK = 0;
		UstPower = 0;
		// Мешалку и воду включаем одновременно, две минуты работаем, минуту отдыхаем.
		if (time1 == 0)
		{
			time1 = 3 * 60;
			timeMIXER = 2 * 60;
			KlOpen[KLP_HLD] = PER_KLP_OPEN;
			KlClose[KLP_HLD] = PER_KLP_CLOSE;
		}
		// Если миксер закончил вращаться, то холодильник тоже отрубаем.
		if (timeMIXER == 0)
		{
			KlOpen[KLP_HLD] = 0;
			KlClose[KLP_HLD] = 100;
		}

		if (temps[TEMP_RAZVAR] <= TempZasypSolod)
		{
			// Если температура меньше либо равна температуре засыпки солода, то переходим к следующему этапу
			// - ожидание засыпки солода.
			StateMachine = 8;
		}
		else
			break;
	case 8: //ожидание засыпки солода, поддержка температуры
		timeNBK = 0;
		SpeedNBK = 0;
		if (FlToGSM && lastSMSState != StateMachine) StateToSMS();
		KlOpen[KLP_HLD] = 0;
		KlClose[KLP_HLD] = 100;
		timeMIXER = 0;
		// Из этого режима можно выйти только вручную, нажав кнопку вверх или отладочной функцией одновременно нажав вверх и вниз.
		// Пищим, чтобы привлечь внимание
		if (BeepStateProcess) my_beep(BEEP_LONG);
		if (temps[TEMP_RAZVAR] < TempZasypSolod - 20)
		{
			UstPower = PowerRazvZerno;
		}
		if (temps[TEMP_RAZVAR] >= TempZasypSolod)
		{
			UstPower = 0;
		}
		time2 = 10 * 60; // Устанавливаем время на работу мешалки после засыпки солода - 10 минут
		time1 = 0;
		break;
	case 9: // Мешаем затор 10 минут.
		timeNBK = 0;
		SpeedNBK = 0;
		UstPower = 0;
		if (time2 > 0)
		{
			// Время работы - 1.5 минуты работы, 30 секунд отдых
			if (time1 == 0)
			{
				time1 = 2 * 60;
				timeMIXER = 2 * 60 - 30;
			}
			break;
		}
		StateMachine = 10;
		time2 = 60 * 60; // Время осахаривания - 1 час.
		if (IspReg == 113)
		{
			time2 = 60 * 60 * 2 / 3; // Время осахаривания - 1.5 часа.
		}

	case 10: // осахаривание затора.
		timeNBK = 0;
		SpeedNBK = 0;
		if (time2 > 0)
		{
			// Время работы - 1 минуты работы, 10 минут отдых
			if (time1 == 0)
			{
				time1 = 10 * 60;
				timeMIXER = 2 * 60;
			}
			break;

			if (temps[TEMP_RAZVAR] < 610)
			{
				UstPower = PowerRazvZerno;
			}
			if (temps[TEMP_RAZVAR] >= 630)
			{
				UstPower = 0;
			}
			break;
		}
		StateMachine = 11;
		time1 = 0;
	case 11: // Остужение до 40 градусов
		// Мешалку и воду включаем одновременно, две минуты работаем, минуту отдыхаем.
		UstPower = 0;
		if (time1 == 0)
		{
			time1 = 4 * 60;
			timeMIXER = 3 * 60;
			KlOpen[KLP_HLD] = PER_KLP_OPEN;
			KlClose[KLP_HLD] = PER_KLP_CLOSE;
		}
		// Если миксер закончил вращаться, то холодильник тоже отрубаем.
		if (timeMIXER == 0)
		{
			KlOpen[KLP_HLD] = 0;
			KlClose[KLP_HLD] = 100;
		}

		if (temps[TEMP_RAZVAR] <= 400)
		{
			// Если температура меньше 40 градосов, то зададим небольшую порцию дрожжей 
			StateMachine = 12;
			SpeedNBK = 125;
			timeNBK = 5;    // Запускаем насос для первоначальной задачи дрожжей
			time1 = 0;
			my_beep(30 * 125);

		}
		else
			break;

	case 12: // Остужение до 355 градусов
		UstPower = 0;
		// Мешалку и воду включаем одновременно, две минуты работаем, 60 секунд отдыхаем.
		if (time1 == 0)
		{
			time1 = 4 * 60;
			timeMIXER = 3 * 60;
			KlOpen[KLP_HLD] = PER_KLP_OPEN;
			KlClose[KLP_HLD] = PER_KLP_CLOSE;
		}
		// Если миксер закончил вращаться, то холодильник тоже отрубаем.
		if (timeMIXER == 0)
		{
			KlOpen[KLP_HLD] = 0;
			KlClose[KLP_HLD] = 100;
		}

		if (temps[TEMP_RAZVAR] <= TempHLDZatorBrog)
		{
			// переходи  к следующему этапу - поддержка брожения.
			StateMachine = 13;
			SpeedNBK = 125;
			timeNBK = 25;    // Запускаем насос для окончательной задачи дрожжей 
			time1 = 0;
			my_beep(60 * 125);
		}
		else
			break;
	case 13: // Поддержка брожения - температура нормальна
		timeNBK = 0;
		SpeedNBK = 0;
		// Поперла пена - мешаем чаще и пищим
		if (flAlarmUroven)
		{
			my_beep(2000);
			{
				if (time1 == 0 || time1 > 3 * 60)
				{
					time1 = 3 * 60;
					timeMIXER = 2 * 60;
					// Звоним на сотовый, что поперла пена раз в три минуты - заливает!!!
					Serial2.print("ATD ");
					Serial2.println(my_phone);
				}
			}
			flAlarmUroven = 0;

		}


		UstPower = 0;
		// Мешалку и воду включаем одновременно, две минуты работаем, 60 секунд отдыхаем.
		if (temps[TEMP_RAZVAR] <= 360)
		{
			KlOpen[KLP_HLD] = 0;
			KlClose[KLP_HLD] = 1000;
			//Если температура меньше 36 градусов, тогда периодически помешиваем, раз в 20 минут на 10 секунд
			if (time1 == 0)
			{
				time1 = 10 * 60;
				timeMIXER = 30;
			}
			break;
		}
		else
		{
			StateMachine = 14;
			time1 = 0;
		}

	case 14: // Поддержка брожения температура превышена
		// Поперла пена
		if (flAlarmUroven)
		{
			my_beep(2000);
			if (time1 == 0)
			{
				// Звоним на сотовый, что поперла пена раз в три минуты - заливает!!!
				Serial2.print("ATD ");
				Serial2.println(my_phone);
			}
			flAlarmUroven = 0;
		}

		if (temps[TEMP_RAZVAR] > 355)
		{
			//Если температура меньше 36 градусов, тогда интенсивно мешаем, раз в 15 минут на 60 секунд
			if (time1 == 0)
			{
				time1 = 3 * 60;
				timeMIXER = 2 * 60;
				KlOpen[KLP_HLD] = PER_KLP_OPEN;
				KlClose[KLP_HLD] = PER_KLP_CLOSE;
			}

			if (timeMIXER == 0)
			{
				KlOpen[KLP_HLD] = 0;
				KlClose[KLP_HLD] = 100;
			}
			break;
		}
		else
		{
			StateMachine = 13;
			time1 = 0;
		}
		break;

	case 100: //Окончание
		// Если необходимо отправлять состояние на сотовый и это состояние еще не отправлялось, тогда информируем о состоянии процесса
		if (FlToGSM && lastSMSState != StateMachine) StateToSMS();
		if (BeepEndProcess) my_beep(BEEP_LONG);
		UstPower = 0;
		CloseAllKLP();
		//    digitalWrite(PIN_REG_ON,LOW);
		digitalWrite(PIN_RZG_ON, !RELAY_HIGH);
		digitalWrite(PIN_ALL_OFF, ALL_OFF_HIGH);
		flAllOff = 1;

		break;
	}
}

void ProcessHLDZatorByChiller()
{
	switch (StateMachine)
	{
	case 0: //Не запущено
		break;
	case 1: //Инициализация
		timeNBK = 0;
		SpeedNBK = 0;
		// Этот пункт пропускаем, потому что и так работает мешалка.
		//      
		//  
		//      // Если необходимо отправлять состояние на сотовый и это состояние еще не отправлялось, тогда информируем о состоянии процесса
		//  //    if (FlToGSM && lastSMSState!=StateMachine) StateToSMS();
		lastSMSState = 0;
		//  
		//  
		//      if (temps[TEMP_RAZVAR]<500)
		//      {
		//        UstPower=Power;
		//        break;
		//      }
		StateMachine = 12;
		//      if (BeepStateProcess) my_beep(BEEP_LONG);
		time1 = 0;
		TempHLDZatorBrog = 245;
	case 12: // Остужение до 355 градусов
		UstPower = 0;
		// Мешалку и воду включаем одновременно, две минуты работаем, 60 секунд отдыхаем.
		if (time1 == 0)
		{
			time1 = 4 * 60;
			timeMIXER = 3 * 60;
			KlOpen[KLP_HLD] = PER_KLP_OPEN;
			KlClose[KLP_HLD] = PER_KLP_CLOSE;
		}
		// Если миксер закончил вращаться, то холодильник тоже отрубаем.
		if (timeMIXER == 0)
		{
			KlOpen[KLP_HLD] = 0;
			KlClose[KLP_HLD] = 100;
		}

		if (temps[TEMP_RAZVAR] <= TempHLDZatorBrog)
		{
			// переходи  к следующему этапу - поддержка брожения.
			StateMachine = 100;
			time1 = 0;
			my_beep(60 * 125);
		}
		else
			break;
	case 100: //Окончание
		// Если необходимо отправлять состояние на сотовый и это состояние еще не отправлялось, тогда информируем о состоянии процесса
		if (FlToGSM && lastSMSState != StateMachine) StateToSMS();
		if (BeepEndProcess) my_beep(BEEP_LONG);
		UstPower = 0;
		CloseAllKLP();
		//    digitalWrite(PIN_REG_ON,LOW);
		digitalWrite(PIN_RZG_ON, !RELAY_HIGH);
		digitalWrite(PIN_ALL_OFF, ALL_OFF_HIGH);
		flAllOff = 1;

		break;
	}

}


void ProcessTermostat()
{
	switch (StateMachine)
	{
	case 0: // Температура Больше необходиомй
		// Процесс не запущен Процесс термостат заппускается автоматически, чтобы он работал даже если выключат и включат свет.
		//break;
	case 1: // Старт процесса
		digitalWrite(PIN_TERMOSTAT_OFF, LOW);// Включаем охлаждение
		digitalWrite(PIN_TERMOSTAT_ON, LOW);// Выключаем нагрев
		StateMachine = 2;
	case 2: // Температура Больше необходиомй
		if (temps[TEMP_TERMOSTAT] <= TempTerm)
		{
			digitalWrite(PIN_TERMOSTAT_OFF, LOW);// Включаем охлаждение
			digitalWrite(PIN_TERMOSTAT_ON, HIGH);// Выключаем нагрев
			UstPower = UstPowerReg; // Подаем полную мощность на ТЭНЫ
			break;
		}
		StateMachine = 3;
		if (BeepStateProcess) my_beep(BEEP_LONG);

	case 3: //
		UstPower = 0; // Убираем мощность с ТЭНов
		if (temps[TEMP_TERMOSTAT] > TempTerm - Delta)
		{
			digitalWrite(PIN_TERMOSTAT_ON, LOW);// Выключаем нагрев
			digitalWrite(PIN_TERMOSTAT_OFF, HIGH);// Включаем охлаждение
			break;
		}
		StateMachine = 2;
		if (BeepStateProcess) my_beep(BEEP_LONG);
		break;
	case 100:// Конечное состояние автомата
		digitalWrite(PIN_ALL_OFF, ALL_OFF_HIGH);
		flAllOff = 1;
		digitalWrite(PIN_TERMOSTAT_ON, LOW);// Выключаем нагрев
		digitalWrite(PIN_TERMOSTAT_OFF, LOW);// Включаем охлаждение
		UstPower = 0; // Убираем мощность с ТЭНов
		break;
	}
}

void ProcessTimerMaxPower()
{
	int minute;
	switch (StateMachine)
	{
	case 0: // 
		// Процесс не запущен
		break;
	case 1: // Старт процесса
		timerMinute = 0;
		StateMachine = 2;
		lastSMSState = 0;
	case 2: // Температура Больше необходиомй
		minute = Seconds / 60;
		if (minute <= timerMinute)
		{
			UstPower = PowerMinute; // Подаем полную мощность на ТЭНЫ
			break;
		}
		StateMachine = 100;
		if (BeepStateProcess) my_beep(BEEP_LONG);
	case 100:// Конечное состояние автомата
		if (FlToGSM && lastSMSState != StateMachine) StateToSMS();
		if (BeepEndProcess) my_beep(BEEP_LONG);
		digitalWrite(PIN_ALL_OFF, ALL_OFF_HIGH);
		flAllOff = 1;
		UstPower = 0; // Убираем мощность с ТЭНов
		break;
	}
}

void ProcessBeerCloneBrau()
{
	// Управление мешалкой;
	if (StateMachine > 0 && StateMachine < 100)
	{
		if (time1 == 0 || temps[TEMP_TERMOSTAT] >= 880)
		{
			// Насос включаем только 
			if (KlOpen[KLP_HLD] == 0 && temps[TEMP_TERMOSTAT] < 880)
			{
				KlOpen[KLP_HLD] = 40;
				KlClose[KLP_HLD] = 0;
				time1 = 10 * 60; // Взводим насос на десять минут работы 
			}
			else
			{
				KlOpen[KLP_HLD] = 0;
				KlClose[KLP_HLD] = 40;
				time1 = 2 * 60; // Взводим насос на две минуты простоя 
			}
		}
	}


	switch (StateMachine)
	{
	case 0: // 
		// Процесс не запущен
		time1 = 0;
		break;
	case 1: // Старт процесса
		KlTek = 0;
		time1 = 0;
		PrepareProcess();
		StateMachine = 2;
	case 2: // Температура Больше необходиомй
		UstPower = PowerVarkaZerno;
		// Если нужная температура меньше 100 градусов, то проверяем пока она не превысит заданную
		// Если нужная температура более 100 градусов, тогда пропускаем этот режим и считаем что началась варка. 
		if (temps[TEMP_TERMOSTAT] < (int)tempP[KlTek] * 10 && tempP[KlTek] <= 100) break;
		StateMachine = 3;
		time2 = (int)timeP[KlTek] * 60;
	case 3:
		if (tempP[KlTek] > 100) UstPower = PowerVarkaZerno;
		else
		{
			if (temps[TEMP_TERMOSTAT] < (int)tempP[KlTek] * 10) UstPower = PowerRazvZerno;
			else  UstPower = 0;
		}

		if (timeP[KlTek] == 0)
			my_beep(2 * BEEP_LONG); // Если время ожидания равно нулю, тогда пищим, ожидая действия пользователя
		else
		{
			if (timeP[KlTek] == 255) timeP[KlTek] = 0;
			if (time2 == 0)
			{
				KlTek++; // Если все паузы выполнены, то переходим к окончанию процесса, иначе к следующей паузе.
				if (KlTek >= CntPause) StateMachine = 100;
				else StateMachine = 2;
				if (BeepStateProcess) my_beep(BEEP_LONG);
			}
		}
		break;
	case 100:// Конечное состояние автомата
		if (FlToGSM && lastSMSState != StateMachine) StateToSMS();
		if (BeepEndProcess) my_beep(BEEP_LONG);
		digitalWrite(PIN_ALL_OFF, ALL_OFF_HIGH);
		CloseAllKLP();
		flAllOff = 1;
		UstPower = 0; // Убираем мощность с ТЭНов
		break;
	}
}

// Процедура по-очереди открывает клапана на 5 секунд
void ScanKLP()
{
	int i;
	lcd.clear();
	lcd.print("KLP NPG ON");
	for (i = 0; i < 10000; i++)
	{
		digitalWrite(PIN_KLP_BEG + KLP_NPG, KLP_HIGH);
		delay(1);
	}


	lcd.clear();
	lcd.print("KLP VODA ON");
	time3 = 10;
	for (i = 0; i < 10000; i++)
	{
		digitalWrite(PIN_KLP_BEG + KLP_VODA, KLP_HIGH);
		delay(1);
	}

	lcd.clear();
	lcd.print("KLP DEFL ON");
	for (i = 0; i < 10000; i++)
	{
		digitalWrite(PIN_KLP_BEG + KLP_DEFL, KLP_HIGH);
		delay(1);
	}

	lcd.clear();
	lcd.print("KLP GLV HVST ON");
	for (i = 0; i < 10000; i++)
	{
		digitalWrite(PIN_KLP_BEG + KLP_GLV_HVS, KLP_HIGH);
		delay(1);
	}

	lcd.clear();
	lcd.print("KLP SR ON");
	for (i = 0; i < 10000; i++)
	{
		digitalWrite(PIN_KLP_BEG + KLP_SR, KLP_HIGH);
		delay(1);
	}

	lcd.clear();
	lcd.print("KLP HLD DIST ON");
	for (i = 0; i < 10000; i++)
	{
		digitalWrite(PIN_KLP_BEG + KLP_HLD, KLP_HIGH);
		delay(1);
	}

}

void ProcessTestKLP()
{
	switch (StateMachine)
	{
	case 0: // Процесс не запущен
		break;
	case 1: // Начало процесса
		PrepareProcess();
		ProcChimSR = 2;
		ScanKLP();
		StateMachine = 2;
		if (BeepStateProcess) my_beep(BEEP_LONG);
		SecTempPrev = Seconds; // Запоминаем дату последнего изменения температуры
		if (SIMPLED_VERSION == 0 || SIMPLED_VERSION >= 5) ProcChimSR = 95;
		else ProcChimSR = 4; // Если используется простая версия, то ШИМ всегда 50%, а процент ШИМ-Это номер тестируемого в данный момент клапана.
		// Чтобы при одновременном включении реле не происходил перезапуск контроллера. 
	case 2: // Клапана открыты

		if (SIMPLED_VERSION == 0 || SIMPLED_VERSION >= 5) // В обычной версии тестируем клапана одновременно, с разным ШИМ
		{
			// Клапан общей подачи воды откырт
			KlOpen[KLP_VODA] = ((timeChimRectOtbSR / 10)*ProcChimSR) / 10;
			KlClose[KLP_VODA] = timeChimRectOtbSR - KlOpen[KLP_SR];
			// Клапан НПГ откырт
			KlOpen[KLP_NPG] = KlOpen[KLP_VODA];
			KlClose[KLP_NPG] = KlClose[KLP_VODA];
			// Клапан Холодильника откырт
			KlOpen[KLP_HLD] = KlOpen[KLP_VODA];
			KlClose[KLP_HLD] = KlClose[KLP_VODA];
			// Клапан дефлегматора откырт
			KlOpen[KLP_DEFL] = KlOpen[KLP_VODA];
			KlClose[KLP_DEFL] = KlClose[KLP_VODA];
			// Клапан отбора спирта откырт
			KlOpen[KLP_GLV_HVS] = KlOpen[KLP_VODA];
			KlClose[KLP_GLV_HVS] = KlClose[KLP_VODA];
			// Клапан отбора спирта откырт
			KlOpen[KLP_SR] = KlOpen[KLP_VODA];
			KlClose[KLP_SR] = KlClose[KLP_VODA];

		}
		else
		{ // В упрощенной версии тестируем клапана по-очереди
			// ШИМ всегда 50%, в проценте ШИМ записан номер клапана.
			KlOpen[ProcChimSR] = 300;
			KlClose[ProcChimSR] = 300;
		}
		if (Seconds - SecTempPrev > 600)  // Если с момента запуска прошло более 10 минут, то переходим в режим паузы - 1 минута.
		{
			if (BeepStateProcess) my_beep(BEEP_LONG);
			SecTempPrev = Seconds; // Запоминаем время паузы.
			StateMachine = 3;
			// Закрываем все клапана.
			if (SIMPLED_VERSION == 0 || SIMPLED_VERSION >= 5)
			{
				ProcChimSR -= 5;
				if (ProcChimSR <= 0) ProcChimSR = 100;
			}
			else
			{ // Тестируем клапана.
				ProcChimSR++;
				if (ProcChimSR > 4) ProcChimSR = 2;
			}
			CloseAllKLP();
		}
		break;
	case 3: // Клапана закрыты, ждем 1 минуту
		if (Seconds - SecTempPrev > 60)  // Если с момента запуска прошло более 20 минут, то переходим в режим паузы - 1 минута.
		{
			if (BeepStateProcess) my_beep(BEEP_LONG);
			StateMachine = 2;
		}
		break;
	case 100:
		CloseAllKLP();
		break;
	}
}

//#define MSerial1 Serial2

void GetPhonePDU()
{
	unsigned char i;
	for (i = 1; i <= 9; i += 2)
	{
		pdu_phone[i - 1] = my_phone[i + 1];
		pdu_phone[i] = my_phone[i];
	}
	pdu_phone[10] = 'F';
	pdu_phone[11] = my_phone[11];
	pdu_phone[12] = 0;
}

void toUSARTPDU(char *s)
{
	char ot[20];
	unsigned char i;
	char pdu_header[] = "0011000B91"; // Заголовок ПДУ.
	char pdu_poster[] = "0008FF"; // Заключительная часть ПДУ.
	//unsigned char ot[6];
	//for(i=0;sms_message[i];out[i++]=0); // Очистить выходной массив

	sprintf(ot, "AT+CMGS=%2i", 14 + strlen(s) * 2);// выводим количество окетов

	//    sprintf(ot,"AT+CMGS=18");// выводим количество окетов

	// sprintf(ot,"AT+CMGS=%02X",13+strlen(s));// Если поставить 19, то уже не работает.

	Serial2.println(ot);
	// ждем пятую часть секунды.
	delay(200);

	// Выводим заголовок ПДУ
	Serial2.print(pdu_header);

	//+65027887074
	//Выводим номер телефона в ПДУ формате
	//    for(i=1;i<=9;i+=2)
	//    {
	//      Serial2.write(my_phone[i+1]);
	//      Serial2.write(my_phone[i]);
	//    }
	//    Serial2.write('F');
	//    Serial2.write(my_phone[11]);

	// 

	Serial2.print(pdu_phone);
	Serial2.print(pdu_poster);

	// Выводим длину сообщения в шестнадцатеричном формате.
	sprintf(ot, "%02X", strlen(s) * 2);
	Serial2.print(ot);
	// Выводим само сообщение

	for (i = 0; s[i]; i++)
	{
		sprintf(ot, "00%02X", s[i]);
		Serial2.print(ot);
	}

	Serial2.write(0x1A);

}


void GetState()
{
	int tic1;
	unsigned char hour, minute;
	hour = Seconds / 3600;
	tic1 = Seconds % 3600;
	minute = tic1 / 60;
	sprintf(my_tx_buffer, "%02u:%02u I=%3u S=%3u T=%3u,%3u,%3u V=%4u,%4u OFF=%1i,%4uW,U=%3u,%3imm", hour, minute, IspReg, StateMachine, temps[0], temps[1], temps[2], U_VODA, U_UROVEN, (int)flAllOff, UstPower, MaxVoltsOut, U_MPX5010);

}

void GetStateSerial()
{
	sprintf(my_tx_buffer, "%lu\tT=\t%3u\t%3u\t%3u\tGlv=%4u\tI=%3u\tS=%3u\t%4uW\tOFF=%1i\t%3imm\t%3uV", Seconds, temps[0], temps[1], temps[2], U_GLV, IspReg, StateMachine, UstPower, (int)flAllOff, U_MPX5010, MaxVoltsOut);
	Serial1.println(my_tx_buffer);
}

void GetStateSerialErr()
{
	sprintf(my_tx_buffer, "Err ds18b20 CntDs=%3u NumDs=%3u", CntErrDs18, NumErrDs18);
	Serial1.println(my_tx_buffer);
}


void StateToSMS()
{
	GetState();

#ifndef TESTERR
	toUSARTPDU(my_tx_buffer);
#else
	Serial1.print("SMS: ");
	Serial1.println(my_tx_buffer);
#endif

	// Запоминаем последнее переданное состояние на сотовый.
	lastSMSState = StateMachine;

}

#ifdef DEBUG
void my_debug()
{
	char s_rx;
	char *st1;
	char *stb;
	int val1;
	static char NoScan=0;
	if (!NoScan)
	{
		while (Serial1.available() > 0) 
		{  //если есть доступные данные
			// считываем байт
			s_rx=Serial1.read();
			delay(10);
			if (s_rx==10)
			{
				my_rx_buffer[pos_rx_buffer-1]=0;
				NoScan=1;
				pos_rx_buffer=0;
				// передаем данные в следующем формате:
				// сколькоприбавитьсекунд,Темпереатура1,Температура2, Температура3
				Serial1.print("dbl:");
				Serial1.println(my_rx_buffer);
				stb=my_rx_buffer;
				st1=strchr(stb,',');
				if (st1)
				{
					st1[0]=0;
					//      Serial1.println(stb);
					val1=atoi(stb);
					Seconds=Seconds+val1;
					timeNBK-=val1;   // Время работы насоса НБК в секундах со скоростью SpeedNKB. По истечении этого времени насос остановится
					timeMIXER-=val1; // Время работы двигателя миксера в секундах. По истечении этого времени насос остановится
					time1-=val1;   // Таймер для отсчета секунд 1
					time2-=val1;   // Таймер для отсчета секунд 2
					time3-=val1;   // Таймер для отсчета секунд 3

					stb=st1+1;
				}
				st1=strchr(stb,',');
				if (st1)
				{
					st1[0]=0;
					//      Serial1.println(stb);
					val1=atoi(stb);
					temps[0]=val1;
					stb=st1+1;
				}
				st1=strchr(stb,',');
				if (st1)
				{
					st1[0]=0;
					//       Serial1.println(stb);
					val1=atoi(stb);
					temps[1]=val1;
					stb=st1+1;
				}
				//      Serial1.println(stb);
				val1=atoi(stb);
				temps[2]=val1;
				flNeedAnalyse=1;
				NoScan=0;
			}
			else
			{
				if (pos_rx_buffer>=MY_RX_BUFFER_SIZE) pos_rx_buffer=0;
				my_rx_buffer[pos_rx_buffer]=s_rx;
				pos_rx_buffer++;
			}
		}
	}
	// Окончание анализа отладки
}
#endif


void loop()
{
	int i, j;
	unsigned long SqNapr = 0, SqNaprPrev = 0, FindPower, FindPowerKLP;
	int FindKt, FindKtKLP;
	int TimeOpenTriac1 = 0;
	int U1, U2; //Уровни на выводах
	byte data[12];
	byte present = 0;
	unsigned int raw;
	byte ds18b20CRC;
	char s_rx;
	static unsigned int SecondsRing;
	static char *vid_sms;   // Вид СМС - память или Сим-карта
	static char num_sms[10];// Номер СМС.
	static char flSMS = 0; // Признак того, что приходила SMS и она еще не удалена.
	static char fAnGSM = 0; // Состояние анализа входящего звонка
	static char  FlFindPower;
	static char  FlFindPowerKLP;
	char flErrDs18;
	unsigned int tic;
	static char trig_on = true; //Признак того, что выдаем в данном цикле - 0 или 1

#ifdef DEBUG
	my_debug();
#endif

	//  static int PowerPrev=0;
	//  static int UstPowerPrev=0;
	// set the cursor to column 0, line 1
	// (note: line 1 is the second row, since counting begins with 0):
	// print the number of seconds since reset:
	// Если есть необходимость произвести отображениеш  информации на дисплее и среднеквадратичное уже рассчитано.
	// И контроллен находится в режиме "лазанья" по меню, тогда отображаем информацию.
	// Или контроллер не находится в режиме ошибки.
	// Обработка уровней и НПГ
	if (flNeedReadAlarm && StateVolts != 1)
	{
		//    #ifndef DEBUG
		ReadAlarm();
		//    #endif
		flNeedReadAlarm = 0;
	}

	// Для обеспечения равномерности выборки делаем это в цикле подряд.
	while (StateVolts == 1)
	{
#ifdef DEBUG
		if (Serial1.available()) return;
#endif

#if USE_ASC712==0 // если датчик тока не используем, тогда читаем значение и делим его на два
		if (!flCorrASC712)  resultU = (analogRead(PIN_READU) >> 1); // читаем показания с pin А3 и делим их на два, для увеличения измеряемого выходного напряжения.
		else
		{
			if (StateVolts == 1)
			{
				resultU = analogRead(PIN_READI) - 512;  // читаем показания с датчика тока.
				if (resultU < 0) resultU = -resultU;
			}
		}

#else
		// Если используем датчик тока, тогда читаем значение, если оно больше 512, значит приводим его к 512;
		resultU=analogRead(PIN_READI)-512;  // читаем показания с датчика тока.
		if (resultU<0) resultU=-resultU;
#endif                  


		//      data_adc[index_input]=resultU;  
		// Пробуем расчет квадратов на лету.
		SqNaprT = SqNaprT + (unsigned long)resultU* (unsigned long)resultU;
#ifdef TESTRM
		//        tic=(int) TCNT4L | (int) (TCNT4H<<8); // Расчитывааем текущее значение таймера
		//        tic_adc[index_input]=tic;
#endif
		if (index_input < MAX_INDEX_INPUT) index_input++;
		else StateVolts = 0; // Если превышер размер массива, ставим флаг расчета заново.

	}

	if (NeedDisplaying && (StateVolts != 1 || IspReg >= 240) && FlState == 0)
	{
		DisplayData();
	}

	// Сканируем клавиатуру, если установлен флаг.
	if (flNeedScanKbd == 1)
	{
		ScanKbd();
		flNeedScanKbd = 0;
	}

	if (flNeedTemp == 1 && IspReg >= 240)
	{
		flNeedAnalyse = 1;
	}

	if (StateVolts != 1)
	{
		if (flNeedTemp == 1)
		{
			flNoPhase = 1; // временно убираем с фазового управления клапана, чтобы они не закрылись
			OpenKLP(); // открываем на всякий случай все клапана, которые необходимо открыть.
			if (StepOut == 0)
			{
				ds.reset();
				ds.write(0xCC, 1);         // start conversion, with parasite power on at the end
				ds.write(0x44, 1);         // start conversion, with parasite power on at the end
				flNeedTemp = 0;
				StepOut = 1;
			}
			else
			{

				flErrDs18 = 0; // Сбрасываем флаг nошибки датчика ds18b20
				for (j = 0; j < ds1820_devices; j++)
				{
					present = ds.reset();

#ifdef TIMING
					TCNT4H=0x00;
					TCNT4L=0x00;
#endif            

					// Здесь вообще засада, передача кода датчика занимает около 1600 тиков таймера, что гарантирует пропуск регуляции как минимум одного полупериода.
					// Возможно решение - посадить каждый датчик на отдельный ПИН, тогда код датчика передавать не нужно.
					ds.select(ds1820_rom_codes[j]);

#ifdef TIMING
					unsigned int Tic2=(int) TCNT4L | (int) (TCNT4H<<8); // Расчитывааем текущее значение таймера
					sprintf(my_tx_buffer,"TicDs18Select=%i",Tic2);
					FlUsart=1;
#endif

					ds.write(0xBE);         // Read Scratchpad
					//          Serial1.print(present,HEX);
					//          Serial1.print(" ");
					//        Читаем пока только 2 байта из 9, остальные не трогаем.
					for (i = 0; i < 9; i++)
					{
						data[i] = ds.read();
						//            Serial1.print(data[i], HEX);
						//            Serial1.print(" ");
					}
					//          Serial1.print(" CRC=");
					ds18b20CRC = OneWire::crc8(data, 8);

					if (ds18b20CRC != data[8]) //  Ошибка чтения, записываем признак ошибки 
					{
#ifndef DEBUG          
						if (!flErrDs18) // Если ранее в этом сеансе не было ошибок чтения датчика, то прибавляем количество ошибок чтения на единицу
						{
							flErrDs18 = 1;
							CntErrDs18++;
							NumErrDs18 = j + 1; // Запоминаем номер сглючившего датчика.
							if (FlToUSART) GetStateSerialErr();
						}
#endif
					}
					else // Если контрольная сумма совпадает, то считаем, что все нормально.
					{
						raw = (data[1] << 8) | data[0];

#ifndef DEBUG          
						temps[j] = raw * 5 / 8;
#endif

						// Если мы сейчас не находимся в режиме ввода поправок к датчикам, то прибавляем к температуре значение поправки

						if (FlState != 300)
						{
							temps[j] = temps[j] + (int)ds1820_popr[j];
						}
						// Запоминаем максимальную температуру датчиков
						if (Maxtemps[j] < temps[j]) Maxtemps[j] = temps[j];

					}
				}

				StepOut = 0;
				flNeedTemp = 0;

#ifdef DEBUG
				flErrDs18=0;
#endif


				flNoPhase = 0; // восстанавливаем фазовое управление клапанами.

				if (!flErrDs18) // Если не было ошибок, то сбрасываем счетчики.
				{
					flNeedAnalyse = 1;   // Все необходимые данные прочитаны устанавливаем флаг того, что нужно анализировать состояние выполнения процесса.
					CntErrDs18 = 0;
					NumErrDs18 = 0;
				}
			}

		}
	}

	if (CntErrDs18 > MAX_ERR_DS18)
	{
		flNeedAnalyse = 1;
#ifndef TEST
		IspReg = 251;      // Переводим контроллер в режим ошибки датчиков.
#endif
	}



	if (flNeedAnalyse == 1)
	{

		trig_on = !trig_on;
		digitalWrite(PIN_RST_WDT, trig_on); // Выдаем признак работы для внешнего контроля

		if (DispDopInfo == 3) my_beep(BEEP_LONG); // Сначала пищим, предупреждая о необходимости смены тары

#ifdef USE_SLAVE
		SlaveON=digitalRead(PIN_SLAVE_3)*8+digitalRead(PIN_SLAVE_2)*4+digitalRead(PIN_SLAVE_1)*2+digitalRead(PIN_SLAVE_0);
#endif

#ifdef TEST
		Serial1.println("BEGIN PROSSES");
#endif      

		switch (IspReg)
		{
		case 102: //Текущее состояние - термостат
			UstPower = 0;
			ProcessTermostat();
			break;
		case 103: //Текущее состояние - регулятор мощности
#ifndef USE_SLAVE
			if (StateMachine < 100) UstPower = UstPowerReg;
			else UstPower = 0;
			break;
#else
			if (SlaveON==0) UstPower=0;
			if (SlaveON==1) UstPower=Power;
			if (SlaveON==2) UstPower=PowerGlvDistil;
			if (SlaveON==3) UstPower=PowerRect;
			if (SlaveON==4) UstPower=PowerDistil;

#endif
		case 108:
		case 113:
			ProcessRazvarZerno();
			break;
		case 114:
			ProcessHLDZatorByChiller();
			break;
		case 115:
			ProcessTimerMaxPower();
			break;
		case 116:
			ProcessBeerCloneBrau();
			break;
		case 109: //Текущее состояние - ректификация
			ProcessRectif();
			break;
		case 104: //Текущее состояние - первый недробный перегон
		case 106: //Текущее состояние - второй дробный
		case 107: //Текущее состояние - третий дробный
			ProcessSimpleDistill();
			break;
		case 105: //Текущее состояние - отбор голов
			ProcessSimpleGlv();
			break;
		case 110:
			ProcessDistilDefl();
			break;
		case 111:
			ProcessNDRF();
			break;
		case 112:
			ProcessNBK();
			break;
		case 129:
			ProcessTestKLP();
			break;
		case 130:
			if (StateMachine == 1) // Если состояние автомата - не запущено
			{
				//            flRing=1;
				flSyncKLP = true;
				KlOpen[KLP_VODA] = 900;
				KlClose[KLP_VODA] = 100;
				KlOpen[KLP_HLD] = KlOpen[KLP_VODA];
				KlClose[KLP_HLD] = KlClose[KLP_VODA];
				KlState[KLP_HLD] = KlState[KLP_VODA];
				KlCount[KLP_HLD] = KlCount[KLP_VODA];
				KlOpen[KLP_DEFL] = KlOpen[KLP_VODA];
				KlClose[KLP_DEFL] = KlClose[KLP_VODA];
				KlState[KLP_DEFL] = KlState[KLP_VODA];
				KlCount[KLP_DEFL] = KlCount[KLP_VODA];
				KlOpen[KLP_SR] = KlOpen[KLP_VODA];
				KlClose[KLP_SR] = KlClose[KLP_VODA];
				KlState[KLP_SR] = KlState[KLP_VODA];
				KlCount[KLP_SR] = KlCount[KLP_VODA];
				digitalWrite(PIN_TERMOSTAT_ON, HIGH);
				digitalWrite(PIN_TERMOSTAT_OFF, HIGH);
				//             digitalWrite(30,HIGH);
				//             digitalWrite(31,HIGH);
				//             digitalWrite(32,HIGH);


				flSyncKLP = false;

				StateMachine = 100; // Переводим процесс в состояние выполнения
			}
			break;

		case 248:
		case 249:
		case 250:
		case 251:
		case 252:
		case 253:
		case 254:
			StateMachine = 100;
			if (FlToGSM && lastSMSState != StateMachine) StateToSMS();
			// Тревога либо ошибки протечка воды, отключаем воду, отключаем мощность.
			UstPower = 0;
			CloseAllKLP();
			// Пищим, независимо от настроек.
#ifndef TEST
			my_beep(125 * 4);
#endif

			digitalWrite(PIN_RZG_ON, !RELAY_HIGH);
			digitalWrite(PIN_TRIAC, LOW);
			digitalWrite(PIN_ALL_OFF, ALL_OFF_HIGH);
			flAllOff = 1;
			break;

		}

		if (FlToUSART) GetStateSerial();

#ifdef TEST
		Serial1.println("END PROSSES");
#endif      

		flNeedAnalyse = 0;
	}

	if (StateVolts != 1)
	{
		//  анализ сотового   
		if (Serial2.available() > 0)
		{  //если есть доступные данные
			// считываем байт
			s_rx = Serial2.read();

#ifdef TESTGSM
			// Дублируем информацию на Serial1
			Serial1.write(s_rx);
#endif

			switch (fAnGSM)
			{
			case 0:

				if (s_rx == 10)
				{
					my_rx_buffer[pos_rx_buffer - 1] = 0;
					if (strlen(my_rx_buffer) < 40)
					{
						if (!strcmp("RING", my_rx_buffer)) // Если входящий звонок, то определяем номер.
						{
							Serial2.println("AT+CLCC");
							fAnGSM = 1;
						}
						else
						{
							vid_sms = strstr(my_rx_buffer, "+CMTI:");
							if (vid_sms)
							{
								vid_sms += 6;
								vid_sms[5] = 0;
								// Запоминаем номер СМС.
								strcpy(num_sms, &vid_sms[6]);
								// Выдаем запрос на чтение смс из того места, откуда она пришла.
#ifdef TESTGSM
								//                    Serial1.println("TEST SMS:");
								//                    Serial1.println(num_sms);
								//                    Serial1.println(vid_sms);
								//                    Serial1.println("END TEST:");
#endif 

								Serial2.print("AT+CPMS=");
								Serial2.println(vid_sms);
								delay(200);
								// Читаем СМС с заданным номером.
								Serial2.print("AT+CMGR=");
								Serial2.println(num_sms);
								flSMS = 1;
							}


						}
					}
					else
					{ // Если сообщение больше, чем 60 символом, считмаем, что это SMS, полученный из телефона.
#ifdef TESTGSM
						Serial1.print("GETSMS:");
						Serial1.println(my_rx_buffer);
#endif 
						// Ищем в СМС свой номер телефона
						vid_sms = strstr(my_rx_buffer, pdu_phone);

#ifdef TESTGSM
						Serial1.print("addr:");
						Serial1.println((int)vid_sms,HEX);
#endif 

						if (vid_sms)
						{// Если найден номер телефона, тогда выделяем информацию из него
							// Информацией считаем последние четыре принятых байта (то есть один символ в формате Unicode)
							//   
							vid_sms = my_rx_buffer + strlen(my_rx_buffer) - 4;
#ifdef TESTGSM
							Serial1.print("INFOSMS:");
							Serial1.println(vid_sms);
#endif 
							// Если получили команду на включение котроллера, устанавливаем состояние машины в первое рабочее.
							if (!strcmp(sms_start, vid_sms))
							{
#ifdef TESTGSM
								Serial1.println("Start on SMS");
#endif 
								StateMachine = 1;
							}
							// Если получили команду на включение котроллера, устанавливаем состояние машины в конечное.
							if (!strcmp(sms_stop, vid_sms))
							{
								StateMachine = 100;
								digitalWrite(PIN_ALL_OFF, ALL_OFF_HIGH);
								flAllOff = 1;

#ifdef TESTGSM
								Serial1.println("Stop on SMS");
#endif 

							}


						}
						// Если ранее был установлен признак SMS, то удаляем SMS c заданным номером.


						if (flSMS)
						{

#ifdef TESTGSM
							Serial1.print("DELETING:");
							Serial1.println(num_sms);
#endif 

							Serial2.print("AT+CMGD=");
							Serial2.println(num_sms);
							flSMS = 0;
						}
					}

					pos_rx_buffer = 0;
#ifdef TESTGSM
					//               lcd.clear();
					//               my_lcdprint(my_rx_buffer);
					//               delay(1000);
#endif 
					my_rx_buffer[0] = 0;

					// Небольшая задержка, на всякий случай чтобы успел телефон обработать 

				}
				else
				{
					if (pos_rx_buffer >= MY_RX_BUFFER_SIZE) pos_rx_buffer = 0;
					my_rx_buffer[pos_rx_buffer] = s_rx;
					pos_rx_buffer++;
				}
				break;
			case 1:// Ждем первую кавычку
				if (pos_rx_buffer >= MY_RX_BUFFER_SIZE) fAnGSM = 0;
				pos_rx_buffer++;
				if (s_rx == '"')
				{
					pos_rx_buffer = 0;
					fAnGSM = 2;
				}
				break;
			case 2:// Ждем вторую кавычку
				if (s_rx == 10) fAnGSM = 0; // Если встретили возврат каретки, то возврат к обычному режиму 
				if (s_rx == '"')
				{ // Нашли номер
					// Отклоняем вызов.
					Serial2.println("AT+CHUP");
					// Небольшая задержка, на всякий случай чтобы успел телефон обработать 
					delay(200);
					my_rx_buffer[pos_rx_buffer] = 0;
					if (!strcmp(my_rx_buffer, my_phone)) flRing = 1;

#ifdef TESTGSM
					lcd.clear();
					lcd.print(my_rx_buffer);
					delay(1000);
#endif

					fAnGSM = 0;
				}
				else
				{
					if (pos_rx_buffer >= MY_RX_BUFFER_SIZE) pos_rx_buffer = 0;
					my_rx_buffer[pos_rx_buffer] = s_rx;
					pos_rx_buffer++;
				}
			}
		}
		else
		{
			if (flRing == 1)
			{

#ifdef TESTGSM
				lcd.clear();
				lcd.print("my call");
				delay(1000);
#endif
				delay(200);
				// Выдаем состояние состояние контроллера по SMS, вне зависимости от того, указано в настройках отправлять СМС или нет.
				// Ведь для чего-то мы на сотовый звонили?
				StateToSMS();

#ifdef TESTGSM
				Serial1.println(my_tx_buffer);
#endif

				flRing = 0;
			}
		}
		// Окончание анализа сотового  
	}
	//  анализ отладки

	if (FlUsart == 1)
	{
		// Признак того, что надо выдать информацию в ком-порт (есл ее вдруг невозможно сразу выдать, например, из прерывания).
		Serial1.println(my_tx_buffer);
		FlUsart = 0;
	}


	// Начало расчета среднеквадратичного

	if (StateVolts == 2)
	{
#ifdef TESTRM
		Serial1.println("BEGIN SQNAPR");
		TCNT4H=0x00;
		TCNT4L=0x00;
#endif      

		StateVolts = 3;

		// поскольку тут идет преобразование и умножение 32 разрядных чисел, делаем это по необходимости, а не каждый раз (хотя какая разница, тут и таких умножений дохрена)
		SqNapr = (long)220 * 220 * 20 / Power; // Рассчитали сопротивление ТЭНа, умноженное на 20
		R_TEN20 = SqNapr;

#ifdef TESTRM
		Serial1.print("UstPower=");
		Serial1.println(UstPower);
		Serial1.print("Power=");
		Serial1.println(Power);
		Serial1.print("NaprPeregrev=");
		Serial1.println(NaprPeregrev);
		Serial1.print("MaxVoltsOut=");
		Serial1.println(MaxVoltsOut);
		Serial1.print("R_TEN20=");
		Serial1.println(R_TEN20);
#endif


		SqNapr = 0;
		SqNaprPrev = 0;
		MaxVolts = 0;

#ifdef TESTRM
		TCNT4H=0x00;
		TCNT4L=0x00;
#endif

		// Для гарантии рассчитываем среднеквадратичное напряжение
		//    for(i=index_input-1;i>=0;i--)
		//    {
		//
		//      // Сканируем клавиатуру, если установлен флаг.
		//      if (flNeedScanKbd==1 )
		//      {
		//        ScanKbd();
		//        flNeedScanKbd=0;
		//      }
		//
		//      SqNapr=SqNapr+(unsigned long) data_adc[i]* (unsigned long) data_adc[i];
		//      // Если датчик тока не используется, то анализируем полученную мощность
		//
		//      // Считаем сумму для средневыпрямленного напряжения
		//      #ifdef TESTRM
		//        SqNaprPrev=SqNaprPrev+data_adc[i];
		//      #endif
		//      if (data_adc[i]>MaxVolts)
		//      {  
		//        MaxVolts=data_adc[i];
		//      }
		//      
		//    }
		//    #ifdef TESTRM
		//        unsigned int Tic2=(int) TCNT4L | (int) (TCNT4H<<8); // Расчитывааем текущее значение таймера
		//        Serial1.print("TimeSquare=");
		//        Serial1.println(Tic2);
		//    #endif

#ifdef TESTRM
		Serial1.print("SqNapr=");
		Serial1.println(SqNaprT);
		//Считаем напряжение в сети исходя из среднеквадратичного, средневыпрямленного, максимального
		Serial1.print("RMS/AVG/MAX");
		Serial1.write(9);
		Serial1.print((long) my_sqrt(SqNaprT/index_input));
		Serial1.write(9);
		Serial1.println((long)MaxVolts*707/1000);
#endif


#if USE_ASC712==0
		if (!flCorrASC712) // Расчет напряжения
		{

			TekPower = SqNaprT / index_input;     // Определили квадрат напряжения

			// Но фактически мощность подаваемая на ТЭНы меньше из-за падения на симисторе.



			MaxVoltsOut = my_sqrt(TekPower);  // Рассчитываем среднеквадратичное

#ifdef TESTRM
			Serial1.print("index_input=");
			Serial1.println(index_input);
			Serial1.print("TekPower2=");
			Serial1.println(TekPower);
#endif


			TekPower = (TekPower * 20) / R_TEN20; // Определили фактическую мощность в зависимости от сопротивления ТЭНа

#ifdef TESTRM
			Serial1.print("TekPower2=");
			Serial1.println(TekPower);
#endif



			TekPowerKLP = (unsigned long)NaprPeregrev*NaprPeregrev;

#ifdef TESTRM
			Serial1.print("UstPower=");
			Serial1.println(UstPower);
			Serial1.print("FactPower=");
			Serial1.println(FactPower);
			Serial1.print("MaxVoltsOut=");
			Serial1.println(MaxVoltsOut);
			Serial1.print("TekPowerKLP=");
			Serial1.println(TekPowerKLP);
#endif

			TekPowerKLP = TekPowerKLP * 1000 / ((long)MaxVoltsOut* (long)MaxVoltsOut);

			FindKtKLP = TekPowerKLP;// Установили коэффициент поиска мощности для клапанов

			// Проверка минимума и максимума
			if (FindKtKLP > 1000) FindKtKLP = 1000;
			if (FindKtKLP < 5) FindKtKLP = 5;

			if (FactPower > 15 && CorrectASC712 == 2) // Если фактическая мощность рассчитана
			{
				// Это формулы, для ПИД-регулировани, предоставленные коллегой m16 c homedistiller.ru
				//          ;******************************************************************************
				//          ;*
				//          ;*	new_err = Ps_r - Pv			;вычисляем новую ошибку
				//          ;*
				//          ;*
				//          ;*	It = It + ki_r * new_err	        ;считаем интегральную составляющую
				//          ;*
				//          ;*		if ( It < 0.0 ) It = 0.0        ;если интегральная отрицательна то присваиваем ей ноль
				//          ;*		else  if( It > Sc_r ) It = Sc_r	;если интегральная превысит установленный предел то присваиваем значение предела 
				//          ;*
				//          ;*	Dt =  kd_r * ( new_err - old_err )	;считаем дифференциальную
				//          ;*
				//          ;*	Ut = ( new_err*10 + It + Dt ) /  Sc_r	;вычисляем % от максимальной мощности
				//          ;*
				//          ;*		if ( Ut < 0.0 ) Ut = 0.0
				//          ;*		else if ( Ut > 100 ) Ut = 100
				//          ;*
				//          ;*	old_err = new_err                       ;присваиваем значению новой ошибке предыдущую
				//          ;******************************************************************************
				//          где
				//          Ps_r - мощность установленная
				//          Pv   - мощность измеренная
				//          new_err- новая ошибка рассогласования
				//          old_err- предыдущая ошибка рассогласования
				//          Sc_r   - максимальное накопление интегральной составляющей
				//          It     - интегральная
				//          ki_r   - коэф. интегральной
				//          Dt     - дифю составляющая 
				//          kd_r   - коэф. дифференциальной
				//          Ut     - % от макс. мощности
				// Считаем ошибку рассоглавования.

				NewErr = (UstPower - FactPower);

				Dt = NewErr - OldErr;
				It = It + NewErr;
				if (It < -900) It = -900;
				else if (It > 900) It = 900;
				OldErrOut = OldErr; // Старая ошибка для отображения на экране
				OldErr = NewErr; // Запоминаем старую ошибку.
				//          if (UstPower>FactPower) It=It+5;
				//          else 
				//            if (UstPower<FactPower) It=It-5;
			}
			else
			{
				// Если мощность не рассчитана, то считаем, что находимся в режиме отладки и не подключили ТЭНы В этом случае просто делаем фазовое регулирование исходя из
				// входного напряжения, не учитывая фактическую мощность, рассчитанную исходя из датчика тока на ТЭНах
				NewErr = 0;
				OldErr = 0;
				OldErrOut = 0;
				It = 0;
				Dt = 0;
			}

			// Пока без коэффиццииенов
			FindKt = (long)(UstPower + It) * 1000 / TekPower;        // Установили коэффициент поиска мощности для регулятора мощности как соотношение необходимой мощности к имеющейся в данный момент.


			if (FindKt > 1000)
			{
				if (UstPower < Power) DispDopInfo = 3; // Выводим на экран информацию о низком напряжении но только в том случае, когда не в режиме разгона
				FindKt = 1000;
			}
			else
				if (DispDopInfo == 3) DispDopInfo = 0; // Убираем информацию о низком напряжении, если она была ранее установлена

			if (FindKt < 5) FindKt = 5;


#ifdef TESTRM
			Serial1.print("NewErr=");
			Serial1.println(NewErr);
			Serial1.print("OldErr=");
			Serial1.println(OldErrOut);
			Serial1.print("FindKt=");
			Serial1.println(FindKt);
			Serial1.print("FindKtNoErr=");
			Serial1.println((long)(UstPower)*1000/ TekPower);
			Serial1.print("NaprPeregrev=");
			Serial1.println(NaprPeregrev);
			Serial1.print("FindKtKLP=");
			Serial1.println(FindKtKLP);
			Serial1.print("SqNaprT=");
			Serial1.println(SqNapr);
			Serial1.print("SqNaprPrev=");
			Serial1.println(SqNaprPrev);
#endif



			// Поскольку таблица разбита по мощности равномерно в пределах 5/1000 доли, то нет необходимости высчитывать и искать по таблице, достаточно просто поделить.
			TimeOpenTriac = tableT[FindKt / 5 - 1];
			TimeOpenKLP = tableT[FindKtKLP / 5 - 1];

			if (TimeOpenKLP <= 10) TimeOpenKLP = 32000; // Если не нашли нужную мощность, то устанавливаем максимальную.
		}
		else // Это расчет фактического тока и фактической мощности
		{
			SqNaprPrev = SqNaprT * 100 / ((unsigned long)index_input*SENSITIVE_ASC712);
			FindPower = (long)SqNaprPrev*R_TEN20 / (20 * SENSITIVE_ASC712);
			FactPower = FindPower;
			//        if (FactPower>15 && false) // Если фактическая мощность рассчитана
			//        {
			//          NewErr=(UstPower-FactPower);
			//          It=It+NewErr;
			//          if (It<0) It=0;
			//            else if (It>1000) It=1000;
			//            
			//          Dt=NewErr-OldErr;
			//          
			//          OldErrOut=OldErr; // Старая ошибка для отображения на экране
			//          OldErr=NewErr; // Запоминаем старую ошибку.
			//          FindKt=(long)(UstPower+It)*1000/ TekPower;        // Установили коэффициент поиска мощности для регулятора мощности как соотношение необходимой мощности к имеющейся в данный момент.
			//                                                            // пока используем только интегральную составляющую.
			//          if (FindKt>1000) FindKt=1000;
			//          if (FindKt<5) FindKt=5;
			//          TimeOpenTriac=tableT[FindKt/5 - 1];
			//
			//        }


#ifdef TESTRM
			Serial1.print("SqNaprT=");
			Serial1.println(SqNaprT);
			Serial1.print("index_input=");
			Serial1.println(index_input);
			Serial1.print("index_input*SENSITIVE_ASC712=");
			Serial1.println((unsigned long)index_input*SENSITIVE_ASC712);
			Serial1.print("SqNaprPrev=");
			Serial1.println(SqNaprPrev);
			Serial1.print("FindPower=");
			Serial1.println(FindPower);
			Serial1.print("FactPower=");
			Serial1.println(FactPower);
#endif
		}

#endif


		//   Сумму квадратов измерений определили, она хранится в переменной SqNapr.
		//   Теперь надо перевести это в фактический ток.
#if USE_ASC712==1

		// Рассчитали сумму, пересчитанную в фактические значения тока.
		SqNaprPrev=SqNaprT*100/ ( (unsigned long) index_input*SENSITIVE_ASC712);
#ifdef TESTRM
		Serial1.print("SqNapr=");
		Serial1.println(SqNapr);
		Serial1.print("SqNaprPrev=");
		Serial1.println(SqNaprPrev);
#endif



		FindPower=(long) SqNaprPrev*R_TEN20/ (20*SENSITIVE_ASC712);
		FactPower=FindPower;

		MaxVoltsOut=my_sqrt(FindPower*R_TEN20/20);

		// Теперь зная мощность рассчитываем процент для брезенхема
		b_value[0]=(long) UstPower*b_size[0]/(long) FindPower;

		if (b_value[0]>b_size[0] && UstPower<Power) DispDopInfo=3; // Выводим на экран информацию о низком напряжении если находимся не в режиме разгона.
		else
			if (DispDopInfo==3) DispDopInfo=0; // Убираем информацию о низком напряжении, если она была ранее установлена


#ifdef TESTRM
		Serial1.print("MaxVoltsOut=");
		Serial1.println(MaxVoltsOut);
		Serial1.print("FindPower=");
		Serial1.println(FindPower);
		Serial1.print("FactPower=");
		Serial1.println(FactPower);
		Serial1.print("b_value[0]=");
		Serial1.println((int)b_value[0]);
#endif
#endif

#ifdef TESTRM

		Serial1.println("VOLTS");
		Serial1.print("j=");
		Serial1.println(j);
		Serial1.print("SqNapr=");
		Serial1.println(SqNapr);
		Serial1.print("SqNaprPrev=");
		Serial1.println(SqNaprPrev);
		Serial1.print("FindPower=");
		Serial1.println(FindPower);
		Serial1.print("b_value=");
		Serial1.println(b_value[0]);
		Serial1.print("OpenTriac=");
		Serial1.println(TimeOpenTriac);
		Serial1.print("OpenKLP=");
		Serial1.println(TimeOpenKLP);

		Serial1.print("COUNT=");
		Serial1.println(index_input);

		//    for(i=0;i<index_input;i++)
		//    {            
		//      // Сканируем клавиатуру, если установлен флаг.
		//      if (flNeedScanKbd==1 )
		//      {
		//        ScanKbd();
		//        flNeedScanKbd=0;
		//      }
		//
		//      Serial1.print(tic_adc[i]);
		//      Serial1.write(9);
		//      Serial1.println(data_adc[i]);
		//    }                                                    
		Serial1.print("TICZERO=");
		Serial1.write(9);
		Serial1.println(TicZero);

		//    Serial1.println("TABLET");
		//    for(i=0;i<MAX_TABLE_T;i++)
		//    {            
		//      // Сканируем клавиатуру, если установлен флаг.
		//      if (flNeedScanKbd==1 )
		//      {
		//        ScanKbd();
		//        flNeedScanKbd=0;
		//      }
		//
		//      Serial1.print(tableK[i]);
		//      Serial1.write(9);
		//      Serial1.println(tableT[i]);
		//    }                                                    

		Serial1.println("ENDVOLTS");


#endif      

		StateVolts = 4;
	}

}